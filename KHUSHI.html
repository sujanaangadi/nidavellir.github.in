<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Industry Business Ideas</title>

<!-- NAVBAR STYLING -->
<style>
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #0d131d;
    color: #d9e5e7;
}

.navbar {
    width: 100%;
    background: #0A1A3A;
    padding: 20px 40px;
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 10;
}

.navbar .logo {
    font-size: 28px;
    font-weight: 700;
    color: white;
    margin-right: 40px;
}

.navbar ul {
    display: flex;
    list-style: none;
    gap: 25px;
    margin: 0;
    padding: 0;
}

.navbar ul li a {
    text-decoration: none;
    color: #C8D6FF;
    font-size: 18px;
    font-weight: 600;
    transition: 0.3s;
}

.navbar ul li a:hover {
    color: #00E5A8;
}
</style>

<!-- PAGE CONTENT STYLING -->
<style>

.header {
    width: 92%;
    margin: auto;
    margin-top: 100px; /* adjusted for navbar */
    text-align: center;
}
.title {
    font-size: 40px;
    font-weight: bold;
    color: #22d3ee;
    text-shadow: 0 0 10px #22d3ee;
}

.container {
    width: 92%;
    margin: auto;
    margin-top: 25px;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 25px;
}


.hero {
    width: 100%;
    margin-top: 90px; /* space below navbar */
    background: #e9f2df;
    padding: 50px 0;
}

.hero-content {
    width: 92%;
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 40px;
}

.hero-text {
    flex: 1;
}

.hero-text h1 {
    font-size: 48px;
    font-weight: 800;
    color: #1f7a1f;
}

.hero-image {
    flex: 1;
    display: flex;
    justify-content: flex-end;
}

.hero-image img {
    width: 100%;
    max-width: 480px;
    border-radius: 18px;
    box-shadow: 0 12px 30px rgba(0,0,0,0.25);
}

.header-orient {
    width: 92%;
    margin: auto;
    margin-top: 100px; /* already adjusted for navbar */
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.header-orient h2 {
    font-size: 40px;
    font-weight: bold;
    color: #22d3ee;
    text-shadow: 0 0 10px #22d3ee;
}

.header-orient img {
    width: 380px;       /* adjust size if needed */
    max-width: 100%;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
}

.card {
    background: #111a22;
    padding: 20px;
    border-radius: 12px;
    border-left: 4px solid #22d3ee;
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    transition: transform 0.25s ease, box-shadow 0.25s ease;
    color: white; /* ALL text white */
}

.card:hover {
    transform: translateY(-8px);
    box-shadow: 0 8px 25px rgba(34,211,238,0.4);
    border-left-color: #67e8f9;
}

.card h3 {
    color: #ffffff; /* headings white */
}

.card b {
    color: #ffffff; /* bold labels white */
}

.card ul li {
    color: #ffffff; /* list items white */
}

pre {
    background: #0a0f17;
    padding: 12px;
    border-radius: 8px;
    display: none;
    white-space: pre-wrap;
    border: 1px solid #1b2a35;
    color: #22d3ee;
}

.algo-btn {
    background: #22d3ee;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    display: inline-block;
    margin-top: 10px;
    color: #0d131d;
    font-weight: bold;
}

.algo-btn:hover {
    background: #67e8f9;
}

/* TABLE & CHART STYLING */
table {
    width: 92%;
    margin: 40px auto;
    border-collapse: collapse;
    background: #111a22;
    color: #d9e5e7;
    border-radius: 10px;
    overflow: hidden;
    font-size: 16px;
}

th, td {
    padding: 12px;
    border: 1px solid #1e2a36;
    text-align: center;
}

th {
    background: #22d3ee;
    color: black;
    font-weight: bold;
}

tr:nth-child(even) {
    background: #0f171f;
}

.chart-box {
    width: 92%;
    margin: 40px auto;
    background: #111a22;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 4px 18px rgba(0,0,0,0.4);
}
</style>

<!-- SCRIPT FOR TOGGLING CODE -->
<script>
function toggleAlgo(id) {
    const x = document.getElementById(id);
    x.style.display = x.style.display === "block" ? "none" : "block";
}
</script>
</head>

<body>

<!-- NAVBAR -->
<div class="navbar">
    <div class="logo">CITY DESIGN</div>
    <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="project.html">Project</a></li>
        <li><a href="SHRAVANA.html">SHRAVANA</a></li>
        <li><a href="SUJANA.html">SUJANA</a></li>
        <li><a href="KHUSHI.html">KHUSHI</a></li>
        <li><a href="LAXMI.html">LAXMI</a></li>
        <li><a href="collabz.html">Collabz</a></li>
    </ul>
</div>

<div class="header-orient">
    <h2>Industry Business Ideas</h2>

    <img src="Screenshot 2025-12-11 172452.png" alt="Business Ideas Image">
</div>
</div>
         </div>
<div class="container">

<!-- ------------------------------------------------------- -->
<!-- 1) Smart Textile Quality Detector -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>1) Smart Textile Quality Detector</h3>

<b>Algorithms Used:</b> KMP Pattern Matching, BFS/DFS  
<br><br>

<b>Explanation:</b>
<ul>
<li>Industries scan fabric surfaces for repeated defect patterns such as holes or weaving errors.</li>
<li>KMP Pattern Matching helps detect patterns efficiently without rechecking characters.</li>
<li>BFS/DFS can map how defects are spreading across the cloth area.</li>
<li>This automation reduces manual inspection time and increases textile quality.</li>
</ul>
<b>Working:</b>
<ul>
<li>Fabric surface data is represented as a sequence or grid.</li>
<li>KMP Pattern Matching scans the fabric data to detect known defect patterns.</li>
<li>Once a defect is detected, BFS/DFS starts from that point.</li>
<li>BFS/DFS explores neighboring fabric regions to identify defect spread.</li>
<li>Defective regions are marked and quality status is generated automatically.</li>
</ul>


<b>Time Complexity:</b> O(n + m)  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 12 (Responsible Consumption & Production)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c1')">Show Code</span>
<pre id="c1">
#include <bits/stdc++.h>
using namespace std;

vector<int> buildLPS(vector<int>& pat){
    vector<int> lps(pat.size(), 0);
    int len = 0;
    for(int i=1;i<pat.size();){
        if(pat[i] == pat[len]) lps[i++] = ++len;
        else if(len) len = lps[len-1];
        else i++;
    }
    return lps;
}

bool KMP(vector<int>& text, vector<int>& pat){
    auto lps = buildLPS(pat);
    int i=0, j=0;
    while(i < text.size()){
        if(text[i] == pat[j]){ i++; j++; }
        else if(j) j = lps[j-1];
        else i++;

        if(j == pat.size()) return true;
    }
    return false;
}

int main(){
    vector<int> cloth = {3,4,4,7,4,4,7};
    vector<int> defect = {4,4,7};
    cout << (KMP(cloth, defect) ? "Defect Found" : "No Defect");
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 2) AI-Based Worker Safety Monitoring -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>2) AI-Based Worker Safety Monitoring</h3>

<b>Algorithms Used:</b> Dijkstra’s Algorithm, Priority Queue  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Industrial areas are modeled as interconnected nodes forming a factory map.</li>
  <li>Each path between locations has a weight based on distance and safety level.</li>
  <li>During emergencies like fire or gas leaks, workers must reach the safest exit quickly.</li>
  <li>Dijkstra’s Algorithm calculates the shortest and safest route to exits.</li>
  <li>A priority queue ensures paths with minimum risk are explored first.</li>
</ul>
<b>Working:</b>
<ul>
  <li>The factory layout is converted into a weighted graph.</li>
  <li>The worker’s current location is taken as the source node.</li>
  <li>Dijkstra’s Algorithm starts from the source and evaluates all possible paths.</li>
  <li>A priority queue selects the next safest location with the lowest cost.</li>
  <li>The process continues until the nearest safe exit is reached.</li>
  <li>The safest escape route is displayed and alerts are generated.</li>
</ul>


<b>Time Complexity:</b> O(E log V)  
<br>
<b>Related SDGs:</b> SDG 3 (Good Health & Well-Being), SDG 8 (Decent Work & Economic Growth)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c2')">Show Code</span>
<pre id="c2">
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// Dijkstra's Algorithm
vector<int> dijkstra(int n, int src, vector<vector<pair<int,int>>>& adj) {
    vector<int> dist(n, INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    dist[src] = 0;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (d > dist[u]) continue;

        for (auto &e : adj[u]) {
            int v = e.first;
            int w = e.second;

            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}

int main() {
    int n = 5;
    vector<vector<pair<int,int>>> adj(n);

    adj[0] = {{1,3}, {2,1}};
    adj[1] = {{3,4}};
    adj[2] = {{3,2}};
    adj[3] = {{4,1}};

    vector<int> safe = dijkstra(n, 0, adj);

    for (int d : safe)
        cout << d << " ";

    return 0;
}

</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 3) Predictive Maintenance for Industrial Machines -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>3) Predictive Maintenance for Industrial Machines</h3>

<b>Algorithms Used:</b> Segment Tree, Max Query  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Industrial machines continuously generate sensor data such as vibration and temperature.</li>
  <li>Abnormal spikes in vibration or heat often indicate potential machine failure.</li>
  <li>A Segment Tree efficiently stores sensor readings over time.</li>
  <li>Range Maximum Query is used to detect maximum vibration levels in any given time interval.</li>
  <li>This helps predict machine breakdowns early and schedule maintenance in advance.</li>
</ul>
<b>Working:</b>
<ul>
  <li>Sensor readings are collected at regular time intervals.</li>
  <li>The data is stored in a Segment Tree structure.</li>
  <li>When a query is made, the maximum sensor value in a time range is retrieved.</li>
  <li>If the value exceeds a predefined threshold, a maintenance alert is generated.</li>
  <li>Early detection reduces machine downtime and improves operational safety.</li>
</ul>


<b>Time Complexity:</b> O(log n) per query  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 12 (Responsible Consumption & Production)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c3')">Show Code</span>
<pre id="c3">
#include <bits/stdc++.h>
using namespace std;

int build(vector<int>& a, vector<int>& st, int i, int l, int r){
    if(l==r) return st[i]=a[l];
    int m=(l+r)/2;
    return st[i]=max(build(a,st,2*i+1,l,m),
                     build(a,st,2*i+2,m+1,r));
}

int query(vector<int>& st, int i, int l, int r, int ql, int qr){
    if(qr<l || ql>r) return -1;
    if(ql<=l && r<=qr) return st[i];
    int m=(l+r)/2;
    return max(query(st,2*i+1,l,m,ql,qr),
               query(st,2*i+2,m+1,r,ql,qr));
}

int main(){
    int n; cin>>n;
    vector<int> vib(n);
    for(int &x:vib) cin>>x;

    vector<int> st(4*n);
    build(vib,st,0,0,n-1);

    int L,R; cin>>L>>R;
    int mx = query(st,0,0,n-1,L,R);

    cout << (mx>100 ? "Maintenance Needed" : "Normal");
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 4) Autonomous Material Sorting Robot -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>4) Autonomous Material Sorting Robot</h3>

<b>Algorithms Used:</b> Classification Logic, Conditional Checks  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Autonomous robots are used in factories and warehouses to sort materials efficiently.</li>
  <li>Each item is analyzed based on attributes such as weight, size, or shape.</li>
  <li>Conditional checks classify items into categories like light, medium, or heavy.</li>
  <li>The robot places items into appropriate bins based on the classification result.</li>
  <li>This automation reduces manual effort and increases sorting accuracy.</li>
</ul>

<b>Working:</b>
<ul>
  <li>Sensors measure the weight and size of incoming materials.</li>
  <li>The robot applies predefined conditional rules for classification.</li>
  <li>Based on the conditions, each item is assigned to a specific category.</li>
  <li>Actuators move the item to the correct sorting area.</li>
  <li>The process repeats continuously for all incoming materials.</li>
</ul>

<b>Time Complexity:</b> O(1)  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 8 (Decent Work And Economic Growth)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c4')">Show Code</span>
<pre id="c4">
#include <bits/stdc++.h>
using namespace std;

string classify(float w){
    if(w < 1) return "Light";
    if(w < 5) return "Medium";
    return "Heavy";
}

int main(){
    int n; cin>>n;
    while(n--){
        float w; 
        cin>>w;
        cout << classify(w) << "\n";
    }
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 5) Smart Inventory Forecasting System -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>5) Smart Inventory Forecasting System</h3>

<b>Algorithms Used:</b> Moving Average, Summation  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Industries maintain daily records of product usage and sales.</li>
  <li>Demand often fluctuates due to seasonal or operational factors.</li>
  <li>The Moving Average method smooths short-term variations in data.</li>
  <li>Summation is used to compute total demand over a fixed period.</li>
  <li>This system helps forecast near-future inventory requirements accurately.</li>
</ul>

<b>Working:</b>
<ul>
  <li>Daily inventory consumption data is collected over a time window.</li>
  <li>The sum of usage values within the window is calculated.</li>
  <li>The moving average is obtained by dividing the sum by the number of days.</li>
  <li>The predicted value is used to plan stock replenishment.</li>
  <li>This prevents overstocking and avoids stock-out situations.</li>
</ul>

<b>Time Complexity:</b> O(n)  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 12 (Responsible Consumption & Production)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c5')">Show Code</span>
<pre id="c5">
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; 
    cin>>n;
    vector<int> s(n);
    for(int &x:s) cin>>x;

    int sum = accumulate(s.begin(), s.end(), 0);
    cout << "Forecast: " << sum/n;
}
</pre>
</div>
<!-- ------------------------------------------------------- -->
<!-- 6) Waste-Heat Energy Recycling System -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>6) Waste-Heat Energy Recycling System</h3>

<b>Algorithms Used:</b> Max Heap, Threshold Calculation  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Industrial machines and boilers produce large amounts of waste heat.</li>
  <li>Temperature sensors continuously record heat levels from different sources.</li>
  <li>A Max Heap organizes heat readings so the highest temperatures are accessed first.</li>
  <li>Only heat values above a defined threshold (for example, 40°C) are selected.</li>
  <li>Selected heat is recycled and converted into usable electrical or thermal energy.</li>
</ul>

<b>Working:</b>
<ul>
  <li>Heat data from multiple sources is collected and inserted into a Max Heap.</li>
  <li>The hottest heat source is extracted first from the heap.</li>
  <li>A threshold check determines whether the heat is reusable.</li>
  <li>If the temperature exceeds the threshold, energy conversion is initiated.</li>
  <li>This process continues until all valid heat sources are processed.</li>
</ul>

<b>Time Complexity:</b> O(n log n)  
<br>
<b>Related SDGs:</b> SDG 7 (Affordable & Clean Energy), SDG 13 (Climate Action)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c6')">Show Code</span>
<pre id="c6">
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin >> n;

    priority_queue<float> pq;
    for(int i=0;i<n;i++){
        float t;
        cin >> t;
        pq.push(t);
    }

    float total = 0;
    while(!pq.empty()){
        float t = pq.top();
        pq.pop();

        float energy = max(0.0f, (t - 40) * 0.6f);
        cout << "Temp " << t << "°C -> " << energy << " kW\n";
        total += energy;
    }

    cout << "Total Recycled Energy: " << total << " kW";
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 7) AI-Based Product Packaging Optimization -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>7) AI-Based Product Packaging Optimization</h3>

<b>Algorithms Used:</b> Binary Search, Sorting  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Products have different sizes and volumes that require suitable packaging.</li>
  <li>Using oversized boxes leads to material waste and higher costs.</li>
  <li>Available box sizes are first sorted in increasing order.</li>
  <li>Binary Search efficiently finds the smallest box that can fit the product.</li>
  <li>This approach minimizes packaging material and speeds up packing operations.</li>
</ul>

<b>Working:</b>
<ul>
  <li>Product dimensions are measured using sensors or input data.</li>
  <li>All available box sizes are sorted beforehand.</li>
  <li>Binary Search is applied to locate the minimum suitable box.</li>
  <li>The selected box is assigned for packaging the product.</li>
  <li>Optimized packaging reduces waste and improves efficiency.</li>
</ul>

<b>Time Complexity:</b> O(log n)  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 12 (Responsible Consumption & Production)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c7')">Show Code</span>
<pre id="c7">
#include <bits/stdc++.h>
using namespace std;

vector<int> boxes = {100, 300, 500};

int findBox(int v){
    int low=0, high=boxes.size()-1, ans=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(boxes[mid] >= v){
            ans = mid;
            high = mid - 1;
        } else low = mid + 1;
    }
    return ans;
}

int main(){
    int n;
    cin >> n;

    while(n--){
        int v;
        cin >> v;
        int idx = findBox(v);

        if(idx == -1) cout << "No suitable box\n";
        else cout << "Use box: " << boxes[idx] << " ml\n";
    }
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 8) Faulty Product Auto-Reject Conveyor System -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>8) Faulty Product Auto-Reject Conveyor System</h3>

<b>Algorithms Used:</b> Range Checking, Instant Validation  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Products move along a conveyor belt equipped with weight sensors.</li>
  <li>Each product’s weight is measured in real time.</li>
  <li>A valid weight range is predefined (90g to 110g).</li>
  <li>Products outside the valid range are identified as faulty.</li>
  <li>Automatic rejection maintains product quality and consistency.</li>
</ul>

<b>Working:</b>
<ul>
  <li>The conveyor belt carries products over the weight sensor.</li>
  <li>The sensor records the weight of each product instantly.</li>
  <li>A range check validates whether the weight lies between 90g and 110g.</li>
  <li>If the product is out of range, a rejection mechanism is triggered.</li>
  <li>Valid products continue forward for packaging.</li>
</ul>

<b>Time Complexity:</b> O(1)  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 12 (Responsible Consumption & Production)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c8')">Show Code</span>
<pre id="c8">
#include <bits/stdc++.h>
using namespace std;

bool reject(float w){
    return (w < 90 || w > 110);
}

int main(){
    int n; 
    cin >> n;

    while(n--){
        float w;
        cin >> w;

        if(reject(w)) cout << "Rejected\n";
        else cout << "Accepted\n";
    }
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 9) Factory Pollution Monitoring & Control Dashboard -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>9) Factory Pollution Monitoring & Control Dashboard</h3>

<b>Algorithms Used:</b> Segment Tree, Range Max Query  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Factories continuously monitor pollution levels across different zones.</li>
  <li>Sensors record data such as gas concentration and air quality indices.</li>
  <li>A Segment Tree efficiently stores pollution readings over time or zones.</li>
  <li>Range Maximum Query helps quickly detect pollution spikes.</li>
  <li>This enables timely action to ensure worker safety and regulatory compliance.</li>
</ul>

<b>Working:</b>
<ul>
  <li>Pollution sensor data is collected from multiple factory zones.</li>
  <li>The readings are organized using a Segment Tree structure.</li>
  <li>Range Maximum Queries are performed to find high-pollution areas.</li>
  <li>Alerts are generated when pollution exceeds safe limits.</li>
  <li>Ventilation or control measures are activated immediately.</li>
</ul>

<b>Time Complexity:</b> O(log n)  
<br>
<b>Related SDGs:</b> SDG 3 (Good Health & Well-Being), SDG 13 (Climate Action)<br><br>
    
<span class="algo-btn" onclick="toggleAlgo('c9')">Show Code</span>
<pre id="c9">
#include <bits/stdc++.h>
using namespace std;

int build(vector<int>& a, vector<int>& st, int i, int l, int r){
    if(l==r) return st[i] = a[l];
    int m = (l+r)/2;
    return st[i] = max(
        build(a, st, 2*i+1, l, m),
        build(a, st, 2*i+2, m+1, r)
    );
}

int query(vector<int>& st, int i, int l, int r, int L, int R){
    if(R < l || L > r) return -1;
    if(L <= l && r <= R) return st[i];
    int m = (l+r)/2;
    return max(
        query(st, 2*i+1, l, m, L, R),
        query(st, 2*i+2, m+1, r, L, R)
    );
}

int main(){
    int n; 
    cin >> n;

    vector<int> a(n);
    for(int &x : a) cin >> x;

    vector<int> st(4*n);
    build(a, st, 0, 0, n-1);

    int L, R;
    cin >> L >> R;

    int mx = query(st, 0, 0, n-1, L, R);

    if(mx > 900) cout << "High Pollution\n";
    else cout << "Normal\n";
}
</pre>
</div>


<!-- ------------------------------------------------------- -->
<!-- 10) AI-Powered Supply Chain Delay Predictor -->
<!-- ------------------------------------------------------- -->
<div class="card">
<h3>10) AI-Powered Supply Chain Delay Predictor</h3>

<b>Algorithms Used:</b> Delay Calculation, Comparative Analysis  
<br><br>

<b>Explanation:</b>
<ul>
  <li>Industries track shipment data including expected and actual delivery times.</li>
  <li>Comparing these values helps identify delays in the supply chain.</li>
  <li>Delay is calculated as the difference between actual and expected delivery time.</li>
  <li>A positive delay value indicates that the shipment is late.</li>
  <li>Early detection of delays helps prevent supply chain disruptions.</li>
</ul>

<b>Working:</b>
<ul>
  <li>Expected delivery time is recorded for each shipment.</li>
  <li>Actual delivery time is captured when the shipment arrives.</li>
  <li>The delay is calculated using: delay = actual − expected.</li>
  <li>Shipments with positive delay values are flagged for review.</li>
  <li>Insights are used to improve logistics planning and coordination.</li>
</ul>
<b>Time Complexity:</b> O(n)  
<br>
<b>Related SDGs:</b> SDG 9 (Industry, Innovation & Infrastructure), SDG 8 (Decent Work and Economic Growth)<br><br>
<span class="algo-btn" onclick="toggleAlgo('c10')">Show Code</span>
<pre id="c10">
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; 
    cin >> n;

    vector<float> expected(n), actual(n);

    for(float &x : expected) cin >> x;
    for(float &x : actual) cin >> x;

    for(int i=0;i<n;i++){
        float d = actual[i] - expected[i];
        
        if(d > 0) 
            cout << "Delivery " << i+1 << ": Delayed by " << d << " hours\n";
        else 
            cout << "Delivery " << i+1 << ": On Time\n";
    }
}
</pre>
</div>

</div> <!-- END container -->
</body>
</html>


</div> <!-- container -->

<!-- TABLE -->
<table>
<tr>
    <th>No.</th>
    <th>Business Idea</th>
    <th>Investment (₹)</th>
    <th>Profit (₹)</th>
</tr>
<tr><td>1</td><td>Smart Textile Quality Detector</td><td>40,000</td><td>1,20,000</td></tr>
<tr><td>2</td><td>AI-Based Worker Safety Monitoring</td><td>50,000</td><td>1,80,000</td></tr>
<tr><td>3</td><td>Predictive Maintenance System</td><td>35,000</td><td>1,40,000</td></tr>
<tr><td>4</td><td>Material Sorting Robot</td><td>25,000</td><td>90,000</td></tr>
<tr><td>5</td><td>Smart Inventory Forecasting</td><td>20,000</td><td>75,000</td></tr>
<tr><td>6</td><td>Waste-Heat Energy Recycling</td><td>60,000</td><td>2,30,000</td></tr>
<tr><td>7</td><td>Packaging Optimization System</td><td>30,000</td><td>1,10,000</td></tr>
<tr><td>8</td><td>Auto-Reject Conveyor System</td><td>15,000</td><td>60,000</td></tr>
<tr><td>9</td><td>Pollution Monitoring Dashboard</td><td>45,000</td><td>1,50,000</td></tr>
<tr><td>10</td><td>Supply Chain Delay Predictor</td><td>55,000</td><td>2,00,000</td></tr>
</table>

<!-- CHART -->
<div class="chart-box">
    <canvas id="profitChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const labels = ["Textile","Safety","Maintenance","Sorting","Inventory","Energy","Packaging","Conveyor","Pollution","Supply Chain"];
const profitData = [120000,180000,140000,90000,75000,230000,110000,60000,150000,200000];
const ctx = document.getElementById('profitChart').getContext('2d');

new Chart(ctx, {
    type: 'bar',
    data: {
        labels: labels,
        datasets: [{
            label: "Profit (₹)",
            data: profitData,
            backgroundColor: "rgba(34, 211, 238, 0.7)",
            borderColor: "#22d3ee",
            borderWidth: 2,
            borderRadius: 8
        }]
    },
    options: {
        responsive: true,
        scales: {
            x: { ticks: { color: "#d9e5e7" }, grid: { display: false } },
            y: { ticks: { color: "#d9e5e7" }, grid: { color: "#1e2a36" } }
        }
    }
});
</script>

</body>
</html>
