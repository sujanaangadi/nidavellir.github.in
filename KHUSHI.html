<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Industry Solutions — Algorithms Project</title>

<style>
    body {
        margin: 0;
        display: flex;
        font-family: Arial, sans-serif;
        background: #f6f4fc;
    }

    /* SIDEBAR */
    .sidebar {
        width: 270px;
        height: 100vh;
        background: #ebe4ff;
        padding: 20px;
        border-right: 2px solid #d4c8ff;
        position: fixed;
        overflow-y: auto;
    }

    .sidebar h2 {
        color: #5a23af;
        margin-bottom: 20px;
        text-align: center;
    }

    .menu-item {
        padding: 12px;
        margin: 8px 0;
        background: white;
        border-radius: 8px;
        cursor: pointer;
        border-left: 4px solid #5a23af;
        transition: 0.2s;
    }

    .menu-item:hover {
        background: #f2ebff;
        transform: translateX(5px);
    }

    /* CONTENT AREA */
    .content {
        margin-left: 300px;
        padding: 30px;
        width: calc(100% - 300px);
    }

    .title {
        font-size: 32px;
        font-weight: bold;
        color: #5a23af;
    }

    .section {
        background: white;
        margin-top: 20px;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .section h3 {
        color: #5a23af;
        margin-top: 0;
    }

    /* TAGS */
    .tag {
        display: inline-block;
        padding: 6px 12px;
        background: #e7ddff;
        color: #5a23af;
        border-radius: 20px;
        margin: 4px;
        font-size: 13px;
    }

    /* CODE BUTTON */
    .code-btn {
        background: #5a23af;
        color: white;
        padding: 10px 16px;
        border-radius: 6px;
        display: inline-block;
        margin-top: 10px;
        cursor: pointer;
    }

    .code-btn:hover {
        background: #7c3aed;
    }

    /* MODAL POPUP */
    .modal {
        display: none;
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.6);
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        width: 60%;
        background: #1e1e1e;
        padding: 20px;
        color: white;
        border-radius: 10px;
        max-height: 80vh;
        overflow-y: auto;
    }

    .close {
        color: white;
        float: right;
        font-size: 22px;
        cursor: pointer;
    }
</style>

</head>
<body>

<!-- SIDEBAR -->
<div class="sidebar">
    <h2>Industry Problems</h2>

    <div class="menu-item" onclick="loadPage(1)">1. Textile Quality Detection</div>
    <div class="menu-item" onclick="loadPage(2)">2. Worker Safety Monitoring</div>
    <div class="menu-item" onclick="loadPage(3)">3. Predictive Maintenance</div>
    <div class="menu-item" onclick="loadPage(4)">4. Sorting Robot</div>
    <div class="menu-item" onclick="loadPage(5)">5. Inventory Forecasting</div>
    <div class="menu-item" onclick="loadPage(6)">6. Waste Heat Recycling</div>
    <div class="menu-item" onclick="loadPage(7)">7. Packaging Optimization</div>
    <div class="menu-item" onclick="loadPage(8)">8. Auto-Reject Conveyor</div>
    <div class="menu-item" onclick="loadPage(9)">9. Pollution Dashboard</div>
    <div class="menu-item" onclick="loadPage(10)">10. Supply Chain Predictor</div>
</div>

<!-- CONTENT -->
<div class="content" id="content">
    <h1 class="title">Select a Problem from Sidebar</h1>
    <p>Click any topic to view algorithms, explanation, and C++ implementation.</p>
</div>

<!-- MODAL -->
<div id="codeModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">×</span>
        <pre id="codeHere"></pre>
    </div>
</div>

<script>
const problems = {
1: {
title: "Smart Textile Quality Detector",
tags: ["KMP", "Rabin-Karp", "DFS", "BFS", "Merge Sort", "AVL Tree", "BST", "Heap"],
problem: "Detect fabric defects using algorithmic pattern analysis and threshold-based scanning.",
approach: `
• KMP & Rabin-Karp → Detect repeating defect patterns  
• DFS/BFS → Identify connected defect clusters  
• Merge Sort → Rank defects by severity  
• Trees → Fast threshold lookup  
• Heap → Highest defect priority`,
code: 
`#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

bool isDefective(int v, int e, int t){
    return abs(v-e) > t;
}

int main(){
    int n; cin >> n;
    vector<int> a(n);
    for(int i=0;i<n;i++) cin >> a[i];

    int expected, th;
    cin >> expected >> th;

    for(int i=0;i<n;i++)
        if(isDefective(a[i], expected, th))
            cout << "Defect at " << i << "\\n";
}`},


2: {
title: "AI Worker Safety Monitoring",
tags: ["Binary Search", "AVL Tree", "Heap", "DFS", "BFS", "Dijkstra", "KMP"],
problem: "Monitor worker motion and detect unsafe acceleration patterns.",
approach: `
• Heap → Highest danger alerts first  
• BFS/Dijkstra → Safe evacuation route  
• Binary Search/AVL → Threshold lookup  
• KMP → Pattern match abnormal movement`,
code:
`#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n; cin >> n;
    vector<float> acc(n);

    for(float &x : acc) cin >> x;
    float limit; cin >> limit;

    for(float x : acc)
        cout << (x > limit ? "Unsafe\\n" : "Safe\\n");
}`},


3: {
title: "Predictive Machine Maintenance",
tags: ["Heap", "Segment Tree", "DFS", "BFS", "Dijkstra", "Merge Sort"],
problem: "Predict failures using vibration pattern deviation.",
approach: `
• Segment tree → Range vibration query  
• Heap → Top risky machines  
• DFS/BFS → Failure propagation  
• Merge Sort → Clean vibration ordering`,
code:
`#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n; cin >> n;
    vector<float> vib(n);
    for(float &x : vib) cin >> x;

    float th; cin >> th;

    for(float x : vib)
        cout << (x > th ? "Failure predicted\\n" : "Normal\\n");
}`},


4: {
title: "Autonomous Material Sorting Robot",
tags: ["Quick Sort", "Merge Sort", "Heap Sort", "AVL Tree", "Dijkstra", "BFS"],
problem: "Sort materials into categories based on weight.",
approach: `
• Sorting algorithms → Categorization  
• Dijkstra → Optimal navigation  
• AVL → Quick rule lookup`,
code:
`#include <iostream>
using namespace std;

string classify(float w){
    if(w < 1) return "Light";
    if(w < 5) return "Medium";
    return "Heavy";
}

int main(){
    int n; cin >> n;
    while(n--){
        float w; cin >> w;
        cout << classify(w) << "\\n";
    }
}`},


5: {
title: "Smart Inventory Forecasting",
tags: ["Moving Average", "Segment Tree", "AVL Tree", "Heap", "Binary Search"],
problem: "Predict future stock using recent sales patterns.",
approach: `
• Moving Average → Smooth forecasting  
• Segment Tree → Fast range queries  
• Heap → High-demand item detection`,
code:
`#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n; cin >> n;
    vector<int> s(n);
    for(int &x : s) cin >> x;

    int sum=0;
    for(int v : s) sum+=v;

    cout << "Forecast: " << sum/n;
}`},


6: {
title: "Waste-Heat Energy Recycling",
tags: ["Heap", "Segment Tree", "Binary Search", "DFS", "Dijkstra"],
problem: "Convert excess heat into usable energy.",
approach: `
• Heap → Prioritize hottest sources  
• Binary Search → Locate thresholds  
• Dijkstra → Best heat-flow path`,
code:
`#include <iostream>
using namespace std;

float convertEnergy(float t){
    float base=40, f=0.6;
    return max(0.0f, (t-base)*f);
}

int main(){
    int n; cin >> n;
    float total=0;
    while(n--){
        float x; cin >> x;
        float e = convertEnergy(x);
        total += e;
        cout << "Converted: " << e << " kW\\n";
    }
    cout << "Total: " << total << " kW";
}`},


7: {
title: "Packaging Optimization",
tags: ["Binary Search", "Quick Sort", "Heap", "KMP", "DP"],
problem: "Find minimum-cost packaging for products.",
approach: `
• Binary Search → Best-fit box  
• DP → Cost optimization  
• KMP → Detect packaging structure issues`,
code:
`#include <iostream>
using namespace std;

string box(float v){
    if(v<100) return "Small";
    if(v<300) return "Medium";
    return "Large";
}

int main(){
    int n; cin >> n;
    while(n--){
        float v; cin >> v;
        cout << box(v) << "\\n";
    }
}`},


8: {
title: "Faulty Product Auto-Reject System",
tags: ["Binary Search", "Heap", "AVL Tree", "DFS", "Merge Sort"],
problem: "Automatically remove defective items based on weight.",
approach: `
• Binary Search → Range checking  
• Heap → Worst defects first  
• DFS → Pattern detection`,
code:
`#include <iostream>
using namespace std;

bool reject(float w){
    return (w<90 || w>110);
}

int main(){
    int n; cin >> n;
    while(n--){
        float w; cin >> w;
        cout << (reject(w)?"Rejected":"Accepted") << "\\n";
    }
}`},


9: {
title: "Factory Pollution Dashboard",
tags: ["Segment Tree", "Heap", "DFS", "BFS", "Dijkstra"],
problem: "Monitor CO₂ levels and compute safety alerts.",
approach: `
• Segment Tree → Pollution intervals  
• Heap → Peak pollution  
• BFS/DFS → Spread mapping`,
code:
`#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n; cin >> n;
    vector<float> v(n);
    for(float &x: v) cin >> x;

    for(float x : v)
        cout << (x>900?"High Pollution!":"Normal") << "\\n";
}`},


10: {
title: "Supply Chain Delay Predictor",
tags: ["Dijkstra", "Bellman-Ford", "Floyd-Warshall", "Merge Sort"],
problem: "Predict delivery delays and compute optimal routes.",
approach: `
• Dijkstra → Fastest route  
• Bellman-Ford → Negative delays  
• Merge Sort → Sort delays`,
code:
`#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n; cin >> n;
    vector<float> e(n), a(n);
    for(float &x: e) cin >> x;
    for(float &x: a) cin >> x;

    for(int i=0;i<n;i++){
        float d = a[i]-e[i];
        cout << (d>0 ? "Delayed":"On Time") << "\\n";
    }
}`}
};

// LOAD PAGE FUNCTION
function loadPage(id){
    const p = problems[id];
    document.getElementById("content").innerHTML = `
        <h1 class="title">${p.title}</h1>

        <div class="section">
            <h3>Problem</h3>
            <p>${p.problem}</p>
        </div>

        <div class="section">
            <h3>Algorithms Used</h3>
            ${p.tags.map(t => <span class='tag'>${t}</span>).join("")}
        </div>

        <div class="section">
            <h3>Solution Approach</h3>
            <p>${p.approach.replace(/\n/g,"<br>")}</p>
        </div>

        <div class="code-btn" onclick="showCode(\${p.code}\)">View Code</div>
    `;
}

// MODAL FUNCTIONS
function showCode(c){
    document.getElementById("codeHere").textContent = c;
    document.getElementById("codeModal").style.display = "flex";
}
function closeModal(){
    document.getElementById("codeModal").style.display = "none";
}
</script>

</body>
</html>
