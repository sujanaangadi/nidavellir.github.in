<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAXMI</title>

    <style>
        /* ---------- NAVIGATION BAR --------- */
        .navbar {
            width: 100%;
            background: #8be0ff;
            padding: 20px 40px;
            display: flex;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 10;
        }

        .navbar .logo {
            font-size: 28px;
            font-weight: 700;
            margin-right: 40px;
        }

        .navbar ul {
            display: flex;
            list-style: none;
            gap: 25px;
            margin: 0;
            padding: 0;
        }

        .navbar ul li a {
            text-decoration: none;
            color: black;
            font-size: 18px;
            font-weight: 600;
        }

        /* ---------- PAGE CONTENT STYLING --------- */
        body {
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .content {
            width: 80%;
            background: #001f4d; /* Dark blue background */
            color: white; /* White text */
            margin: 40px auto;
            padding: 30px;
            border-radius: 10px;
            font-size: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .content h2, .content h3, .content h4 {
            color: #a0e1ff; /* Light blue headings for contrast */
        }

        .content ul, .content p {
            line-height: 1.6;
        }

        .content table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            color: white;
        }

        .content table th, .content table td {
            padding: 10px;
            border: 1px solid white;
        }

        .content table th {
            background-color: #003366;
        }

        .title-box {
            width: 80%;
            background: black;
            color: #3cb371;  
            font-size: 40px;
            font-weight: bold;
            margin: 180px auto 40px auto;
            text-align: center;
            padding: 20px;
            border-radius: 15px;
        }

        /* Optional: make links inside content stand out */
        .content a {
            color: #ffcc00;
            text-decoration: underline;
        }
    </style>
</head>

<body>

    <!-- ------------------ NAVBAR ------------------ -->
    <div class="navbar">
        <div class="logo">CITY DESIGN</div>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="project.html">Project</a></li>
            <li><a href="SHRAVANA.html">SHRAVANA</a></li>
            <li><a href="SUJANA.html">SUJANA</a></li>
            <li><a href="KHUSHI.html">KHUSHI</a></li>
            <li><a href="LAXMI.html">LAXMI</a></li>
            <li><a href="collabz.html">Collabz</a></li>
        </ul>
    </div>
<style>
  /* Light Mode (White Background) */
  :root{
    --bg:#ffffff;
    --card:#f5f7fa;
    --accent1:#008000;      /* green */
    --accent2:#0066cc;      /* blue */
    --muted:#333333;        /* dark gray */
    --glass: rgba(0,0,0,0.05);
  }

  *{box-sizing:border-box}

  body{
    margin:0;
    font-family:"Segoe UI", Roboto, Arial, sans-serif;
    background: #DDE8D1;                       /* Nude light green*/
    color:#222;                             /* dark text */
    padding-bottom:80px;
  }

  /* header */
  .header {
    position:fixed;
    left:0; right:0; top:0;
    height:72px;
    display:flex;
    align-items:center;
    gap:24px;
    padding:0 28px;
    background:#bdebff;                     /* light sky blue */
    border-bottom:1px solid #ddd;
    z-index:100;
  }

  .logo {
    color:#000;
    font-weight:800;
    font-size:22px;
  }

  .nav {
    margin-left:auto;
    display:flex;
    gap:18px;
  }
  .nav a{
    color:#000;
    font-weight:600;
    text-decoration:none;
  }

  /* layout */
  .container{
    max-width:1150px;
    margin:110px auto 40px;
    padding:20px;
  }

  .hero{
    display:flex;
    gap:28px;
    align-items:center;
    flex-wrap:wrap;
    margin-bottom:24px;
  }

  .hero h1{
    margin:0 0 8px 0;
    color:#008000;          /* green */
    font-size:38px;
    font-weight:800;
  }

  .hero img{
    width:330px;
    border-radius:14px;
    border:2px solid #00800020;
    box-shadow:0 6px 18px rgba(0,128,0,0.15);
  }

  /* Cards */
  .grid{
    display:grid;
    grid-template-columns:1fr;
    gap:18px;
  }
  @media(min-width:980px){
    .grid{grid-template-columns:1fr 1fr;}
  }

  .card{
    background:#f7f9fb;
    border-radius:14px;
    padding:18px;
    border:1px solid #ddd;
    box-shadow:0 4px 12px rgba(0,0,0,0.08);
  }

  .card h2{
    margin:0;
    color:#0066cc;
    font-size:20px;
  }

  .subtitle{
    color:#008000;
    font-weight:600;
    margin-bottom:10px;
  }

  .meta{
    font-size:15px;
    color:#444;
  }

  /* Button */
  .btn{
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    border:0;
    background:#008000;
    color:white;
    font-weight:700;
  }

  /* Algorithm box */
  .algo{
    display:none;
    background:#e8fff0;
    border:1px solid #00800055;
    border-radius:10px;
    padding:12px;
    margin-top:12px;
  }

  .algo pre{
    background:#ffffff;
    padding:10px;
    border-radius:8px;
    border:1px solid #ccc;
    color:#000;
    overflow:auto;
  }
</style>

  <main class="container">
    <section class="hero">
      <div class="title">
        <h1>Agriculture Business Ideas </h1>
      </div>

      <!-- change this image file name to your generated image -->
      <img src="Screenshot 2025-12-08 201150.png" alt="Smart agriculture image (place smart_agri_green.png here)">
    </section>

    <!-- grid of cards -->
    <section class="grid">

      <!-- 1 -->
      <article class="card">
        <h2>1) Coconut Husk Water-Reservation System</h2>
        <div class="subtitle">Reduce irrigation, hold moisture</div>
        <div class="meta">
          <strong>How to implement:</strong> Mix coconut husk (coir) with soil in beds or pits; use 20–30% coir ratio; mulch surface.<br>
          <strong>Why / Benefits:</strong> Holds 8–10× water, reduces irrigation 40–60%, more yield.<br>
          <strong>Investment:</strong> ₹7,000–₹10,000 per acre • <strong>Profit:</strong> ₹15k–₹25k/yr per acre.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo1">Show Algorithm</button>
        </div>

        <div id="algo1" class="algo">
          <strong>Greedy Water Optimization (pseudocode)</strong>
          <pre>
Divide field into sections S1..Sn
For each section compute moistureLevel[i]

Sort sections by moistureLevel ascending (driest first)
For each section in sorted order:
  if moistureLevel[section] < thresholdLow:
    applyCoir(section)
    irrigateMinimal(section)
  else
    skip

Loop: check moisture every 24 hours, repeat.
</pre>
        </div>
      </article>

      <!-- 2 -->
      <article class="card">
        <h2>2) Organic Vegetable Farming</h2>
        <div class="subtitle">Chemical-free vegetables for market</div>
        <div class="meta">
          <strong>How to implement:</strong> Use compost / cow dung / neem; drip irrigation; polyhouse for high-value crops.<br>
          <strong>Why / Benefits:</strong> Healthier produce & higher price (≈2×), local employment.<br>
          <strong>Investment:</strong> ₹20,000 per acre • <strong>Profit:</strong> ₹60k–₹1,00k/yr per acre.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo2">Show Algorithm</button>
        </div>

        <div id="algo2" class="algo">
          <strong>Dynamic Programming: Crop & Fertilizer Scheduling (pseudocode)</strong>
          <pre>
Let DP[d][c] = best expected yield up to day d if crop c planted
For each day d:
  For each crop option c:
    DP[d][c] = max over previous states ( DP[d-1][x] + benefit(c,d) - cost(c,d) )
Choose crop rotation that maximizes total DP at harvest time.
</pre>
        </div>
      </article>

      <!-- 3 -->
      <article class="card">
        <h2>3) Mushroom Cultivation</h2>
        <div class="subtitle">High-yield small-space farming</div>
        <div class="meta">
          <strong>How to implement:</strong> Build humid shed; use straw/waste + spawn; control humidity and harvesting cycles.<br>
          <strong>Benefits:</strong> Fast cycles (30–35 days), women-friendly, high margin.<br>
          <strong>Investment:</strong> ₹25,000 setup • <strong>Profit:</strong> scalable monthly income.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo3">Show Algorithm</button>
        </div>

        <div id="algo3" class="algo">
          <strong>Kruskal-like Cost Minimization (pseudocode)</strong>
          <pre>
List required items with cost: items = [sheds, spawn, straw, humidifier, trays]
Sort items by cost ascending
selected = []
for item in items:
  if essential(selected + [item]) is true:
    selected.append(item)
  if selected covers minimal requirements:
    break
Budget-check & purchase selected list
</pre>
        </div>
      </article>

      <!-- 4 -->
      <article class="card">
        <h2>4) Hydroponic Farming</h2>
        <div class="subtitle">Soilless, water-efficient farming</div>
        <div class="meta">
          <strong>How to implement:</strong> Use NFT/DWC systems, nutrient solution, pumps, and monitoring.<br>
          <strong>Benefits:</strong> Faster growth, 80–90% less water, premium produce.<br>
          <strong>Investment:</strong> ₹40,000 (small) – ₹1,00,000 (medium) • <strong>Profit:</strong> ₹30k–₹60k/month.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo4">Show Algorithm</button>
        </div>

        <div id="algo4" class="algo">
          <strong>A* Nutrient Optimization (pseudocode)</strong>
          <pre>
Start = current nutrient state
Goal = ideal nutrient target
openSet = {Start}
while openSet not empty:
  node = pop node with lowest f = g + h
  if node == Goal: reconstruct path and apply solution
  for neighbor in neighborStates(node):
    tentative_g = g(node) + costToChange(node,neighbor)
    if tentative_g < g(neighbor):
      cameFrom[neighbor] = node
      g(neighbor) = tentative_g
      f(neighbor) = g(neighbor) + heuristic(neighbor,Goal)
      add neighbor to openSet
</pre>
        </div>
      </article>

      <!-- 5 -->
      <article class="card">
        <h2>5) Dairy + Cow-Dung Products</h2>
        <div class="subtitle">Milk supply + value-added dung goods</div>
        <div class="meta">
          <strong>How to implement:</strong> Collect milk; small chilling; convert dung to manure, diyas, incense.<br>
          <strong>Benefits:</strong> Daily cashflow, zero waste, women-led units.<br>
          <strong>Investment:</strong> ~₹80,000 per cow • <strong>Profit:</strong> ₹8k–₹12k per cow/month.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo5">Show Algorithm</button>
        </div>

        <div id="algo5" class="algo">
          <strong>Max-Heap Priority Scheduling (pseudocode)</strong>
          <pre>
Initialize max-heap H keyed by milkYield
Every morning:
  for each cow:
    insert(H, cow with today's expected milk)
  while H not empty:
    cow = extractMax(H)
    milkCow(cow)
    update cow's expected milk and re-insert if still milking
After milking: route dung to product unit
</pre>
        </div>
      </article>

      <!-- 6 -->
      <article class="card">
        <h2>6) Beekeeping (Honey Production)</h2>
        <div class="subtitle">Honey, wax & better pollination</div>
        <div class="meta">
          <strong>How to implement:</strong> Install boxes in flowering areas; seasonal management & extraction.<br>
          <strong>Benefits:</strong> Good margins, crop pollination increase, low CAPEX.<br>
          <strong>Investment:</strong> ₹5k per box (10 boxes ≈ ₹50k) • <strong>Profit:</strong> ₹40k–₹60k every quarter.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo6">Show Algorithm</button>
        </div>

        <div id="algo6" class="algo">
          <strong>DFS For Hive Foraging Paths (pseudocode)</strong>
          <pre>
Represent fields/flowers as graph G(V,E)
function DFS(node, visited):
  mark node visited
  for neighbor in neighbors(node):
    if not visited[neighbor]:
      visit neighbor (collect nectar)
      DFS(neighbor, visited)

Start DFS from hive nodes each foraging day
Mark visited flowers to avoid repeated short trips
</pre>
        </div>
      </article>

      <!-- 7 -->
      <article class="card">
        <h2>7) Nursery Business (Plants & Saplings)</h2>
        <div class="subtitle">Sell saplings to farmers & towns</div>
        <div class="meta">
          <strong>How to implement:</strong> Shade net area, seed trays, potting mix, drip watering, small staff.<br>
          <strong>Benefits:</strong> Year-round revenue, supports reforestation & orchards.<br>
          <strong>Investment:</strong> ₹30,000 initial • <strong>Profit:</strong> ₹15k–₹40k/month.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo7">Show Algorithm</button>
        </div>

        <div id="algo7" class="algo">
          <strong>Segment Tree for Fast Category Queries (concept)</strong>
          <pre>
Build segment tree where leaf nodes = plant categories and counts
Query(l, r): returns total plants in category range in O(log n)
Update(index, delta): adjust counts when plants sold or grown
Use to quickly answer stock & order queries
</pre>
        </div>
      </article>

      <!-- 8 -->
      <article class="card">
        <h2>8) Medicinal Plant Farming</h2>
        <div class="subtitle">Aloe, Tulsi, Ashwagandha — high value crops</div>
        <div class="meta">
          <strong>How to implement:</strong> Select drought-tolerant species, prepare beds, minimal irrigation, harvest & dry.<br>
          <strong>Benefits:</strong> High demand from pharma & Ayurveda; low water need.<br>
          <strong>Investment:</strong> ₹20,000 per acre • <strong>Profit:</strong> ₹80k–₹1.2L/acre/year.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo8">Show Algorithm</button>
        </div>

        <div id="algo8" class="algo">
          <strong>BST: Batch Tracking & Harvest Order (pseudocode)</strong>
          <pre>
Insert(batch) keyed by plantingDate
Inorder traversal -> batches in age order
Harvest from rightmost nodes (oldest ready)
After harvesting, remove node and insert new batch
</pre>
        </div>
      </article>

      <!-- 9 -->
      <article class="card">
        <h2>9) Solar Farming</h2>
        <div class="subtitle">Small solar plant on unused land</div>
        <div class="meta">
          <strong>How to implement:</strong> Install panels, inverter, net-metering or sell to nearby grid.<br>
          <strong>Benefits:</strong> Passive income, reduces electricity cost.<br>
          <strong>Investment:</strong> ₹1,00,000 (small scale) • <strong>Profit:</strong> ₹7k–₹10k/month.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo9">Show Algorithm</button>
        </div>

        <div id="algo9" class="algo">
          <strong>Prim's MST for Wiring & Layout (pseudocode)</strong>
          <pre>
Nodes = solar panel positions
Edges = wiring costs between nodes
Start with any node; add cheapest connecting edge not forming cycle
Repeat until all nodes connected
Result = wiring layout with minimum total cost
</pre>
        </div>
      </article>

      <!-- 10 -->
      <article class="card">
        <h2>10) Smart Goat Farming Unit</h2>
        <div class="subtitle">Sirohi goats — low water & high returns</div>
        <div class="meta">
          <strong>How to implement:</strong> Build ventilated shed, buy quality kids, vaccination & feeding schedule.<br>
          <strong>Benefits:</strong> Quick breeding, small land, year-round income.<br>
          <strong>Investment:</strong> 10 goats ≈ ₹60,000 • <strong>Profit:</strong> ₹1L–₹1.5L/yr.
        </div>

        <div class="row">
          <button class="btn" data-algo="algo10">Show Algorithm</button>
        </div>

        <div id="algo10" class="algo">
          <strong>Binary Search for Health Record Lookup (pseudocode)</strong>
          <pre>
Store healthRecords[] sorted by date
function findRecord(date):
  left=0; right=len-1
  while left <= right:
    mid=(left+right)//2
    if healthRecords[mid].date == date: return healthRecords[mid]
    if healthRecords[mid].date < date: left = mid+1
    else: right = mid-1
  return null (no record)
Use lookup weekly to quickly find anomalies
</pre>
        </div>
      </article>

    </section>

    <footer>
    </footer>
  </main>

  <script>
    // Toggle algorithms
    document.querySelectorAll('.btn').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const id = btn.getAttribute('data-algo');
        const panel = document.getElementById(id);
        if(!panel) return;
        // toggle open/close and change button text
        if(panel.style.display === 'block'){
          panel.style.display = 'none';
          btn.textContent = 'Show Algorithm';
        } else {
          // close any other open panels
          document.querySelectorAll('.algo').forEach(a => a.style.display = 'none');
          document.querySelectorAll('.btn').forEach(b => b.textContent = 'Show Algorithm');
          panel.style.display = 'block';
          btn.textContent = 'Hide Algorithm';
          // scroll into view smoothly
          panel.scrollIntoView({behavior:'smooth', block:'center'});
        }
      });
    });

    // close algorithm panels when Escape pressed
    document.addEventListener('keydown', e=>{
      if(e.key === 'Escape'){
        document.querySelectorAll('.algo').forEach(a=> a.style.display='none');
        document.querySelectorAll('.btn').forEach(b=> b.textContent='Show Algorithm');
      }
    });
  </script>
</body>
</html>
    <!-- MAIN TITLE -->
    <div class="title-box">DESIGN & ANALYSIS OF ALGORITHMS</div>

    <!-- ------------------ SECTION 1 ------------------ -->
    <div class="content">
        <h2>What is the course about?</h2>
        <p>The Design and Analysis of Algorithms (DAA) course is about developing a deep understanding of how algorithms work, how they are designed, and how they can be optimized for efficiency.</p>
        <ul>
            <li>The systematic design of algorithms</li>
            <li>Time & space complexity</li>
            <li>Greedy, Divide-and-Conquer, Dynamic Programming</li>
            <li>Graph algorithms</li>
            <li>Optimization techniques</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 2 ------------------ -->
    <div class="content">
        <h3>Connection with the real world</h3>
        <p><strong>What data structures and algorithms did I study?</strong></p>
        <p>During the course I explored a variety of data structures and algorithms, including:</p>

        <div style="display:flex;gap:40px;flex-wrap:wrap;">
            <div style="min-width:240px">
                <h4>Data Structures</h4>
                <ul>
                    <li>Arrays, Linked Lists</li>
                    <li>Stacks, Queues</li>
                    <li>Trees, Graphs</li>
                    <li>Hash Tables</li>
                </ul>
            </div>

            <div style="min-width:240px">
                <h4>Algorithms</h4>
                <ul>
                    <li>Sorting: Merge Sort, Quick Sort</li>
                    <li>Graph: Dijkstra’s, Kruskal’s</li>
                    <li>String matching: Rabin–Karp, Boyer–Moore</li>
                </ul>
            </div>
        </div>

        <p>This course is an essential foundation for software engineering, competitive programming, and machine learning — it builds efficient problem-solving skills.</p>
    </div>

    <!-- ------------------ SECTION 3 ------------------ -->
    <div class="content">
        <h3>Course Reflections</h3>

        <h4>1. Natural Problem Patterns</h4>
        <p><strong>Iteration</strong></p>
        <ul>
            <li>Daily routine</li>
            <li>Game turns</li>
            <li>Practice loops</li>
        </ul>

        <p><strong>Recursion</strong></p>
        <ul>
            <li>Tree growth</li>
            <li>Fractal patterns</li>
            <li>Nested structures</li>
        </ul>

        <p><strong>Backtracking</strong></p>
        <ul>
            <li>Finding locations</li>
            <li>Sudoku solving</li>
            <li>Trying alternatives</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 4 ------------------ -->
    <div class="content">
        <h3>Time & Space Efficiency</h3>
        <p>Algorithms are measured by how efficiently they use time and memory. Time complexity measures the number of operations, while space complexity measures memory usage.</p>

        <table>
            <thead>
                <tr>
                    <th>Order</th>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>O(1)</td>
                    <td>Constant</td>
                    <td>Minimal</td>
                    <td>Accessing array element</td>
                </tr>
                <tr>
                    <td>O(log n)</td>
                    <td>Logarithmic</td>
                    <td>Low</td>
                    <td>Binary search</td>
                </tr>
                <tr>
                    <td>O(n)</td>
                    <td>Linear</td>
                    <td>Moderate</td>
                    <td>Linear search</td>
                </tr>
                <tr>
                    <td>O(n²)</td>
                    <td>Quadratic</td>
                    <td>High</td>
                    <td>Bubble sort</td>
                </tr>
                <tr>
                    <td>O(2ⁿ)</td>
                    <td>Exponential</td>
                    <td>Very High</td>
                    <td>Brute-force TSP</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- ------------------ SECTION 5 ------------------ -->
    <div class="content">
        <h3>Hierarchical Data & Tree Structures</h3>
        <table>
            <thead>
                <tr>
                    <th>Tree Type</th>
                    <th>Best For</th>
                    <th>Strength</th>
                    <th>Limitation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>BST</td>
                    <td>Sorted data, moderate updates</td>
                    <td>Simple structure</td>
                    <td>Can become unbalanced</td>
                </tr>
                <tr>
                    <td>AVL Tree</td>
                    <td>Frequent lookups</td>
                    <td>Guaranteed balance</td>
                    <td>Costly rotations</td>
                </tr>
                <tr>
                    <td>2-3 Tree</td>
                    <td>Predictable performance</td>
                    <td>Consistent height</td>
                    <td>Implementation complexity</td>
                </tr>
                <tr>
                    <td>Red-Black Tree</td>
                    <td>Dynamic datasets</td>
                    <td>Fewer rotations</td>
                    <td>Slightly less balanced</td>
                </tr>
                <tr>
                    <td>Heap</td>
                    <td>Priority-based operations</td>
                    <td>Efficient min/max</td>
                    <td>Not for general search</td>
                </tr>
                <tr>
                    <td>Trie</td>
                    <td>Strings & prefix searches</td>
                    <td>Fast prefix search</td>
                    <td>High memory usage</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- ------------------ SECTION 6 ------------------ -->
    <div class="content">
        <h3>Array Query Algorithms</h3>
        <p><strong>Principles:</strong> Divide and conquer, dynamic programming, optimization.</p>
        <p><strong>Purpose:</strong> Efficiently retrieve, manipulate, or analyze large datasets.</p>
        <ul>
            <li>Binary Index Tree: O(log n), for sorted arrays.</li>
            <li>Sliding Window: O(n), for overlapping subarray analysis.</li>
            <li>Segment Tree: O(log n), for range queries.</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 7 ------------------ -->
    <div class="content">
        <h3>Trees and Graphs</h3>
        <p><strong>Difference:</strong></p>
        <ul>
            <li>Tree: Hierarchical, no cycles. Example: File system.</li>
            <li>Graph: Can have cycles, flexible connections. Example: City map.</li>
        </ul>

        <p><strong>Tree Traversals:</strong></p>
        <ul>
            <li>In-Order: Left → Node → Right (sorting)</li>
            <li>Pre-Order: Node → Left → Right (copying)</li>
            <li>Post-Order: Left → Right → Node (deletion)</li>
            <li>Level-Order (BFS): Visit nodes level by level</li>
        </ul>

        <p><strong>Graph Traversals:</strong></p>
        <ul>
            <li>DFS: Go deep before backtracking (maze solving)</li>
            <li>BFS: Explore level by level (shortest paths)</li>
        </ul>

        <p><strong>Applications:</strong></p>
        <ul>
            <li>Trees: File systems, decision trees, databases</li>
            <li>Graphs: Social networks, GPS navigation, web crawlers</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 8 ------------------ -->
    <div class="content">
        <h3>Sorting & Searching Algorithms</h3>
        <h4>Sorting</h4>
        <ul>
            <li>Bubble Sort: Swap adjacent items. Small datasets.</li>
            <li>Selection Sort: Pick smallest each time. Minimizes swaps.</li>
            <li>Insertion Sort: Insert items in correct position. Nearly sorted data.</li>
            <li>Merge Sort: Divide and merge. Large datasets.</li>
            <li>Quick Sort: Pivot-based divide. Fast for large data.</li>
            <li>Heap Sort: Uses heap structure. Efficient for priority queues.</li>
        </ul>
        <h4>Searching</h4>
        <ul>
            <li>Linear Search: Check each item sequentially.</li>
            <li>Binary Search: Divide and conquer on sorted data.</li>
            <li>BFS/DFS: Shortest path or complete exploration in graphs.</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 9 ------------------ -->
    <div class="content">
        <h3>Graph Algorithms: Shortest Paths & Spanning Trees</h3>
        <table>
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Purpose</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Dijkstra</td>
                    <td>Single-source shortest path</td>
                    <td>Weighted graphs, navigation</td>
                </tr>
                <tr>
                    <td>Floyd-Warshall</td>
                    <td>All-pairs shortest paths</td>
                    <td>Dense graphs</td>
                </tr>
                <tr>
                    <td>Prim</td>
                    <td>Minimum Spanning Tree</td>
                    <td>Network design</td>
                </tr>
                <tr>
                    <td>Kruskal</td>
                    <td>Minimum Spanning Tree</td>
                    <td>Cost optimization</td>
                </tr>
                <tr>
                    <td>Bellman-Ford</td>
                    <td>Shortest paths with negative weights</td>
                    <td>Graphs with negative edges</td>
                </tr>
            </tbody>
        </table>

        <h3>Algorithm Design Techniques</h3>
        <ul>
            <li>Brute Force: Try all solutions. Simple but slow.</li>
            <li>Divide & Conquer: Split, solve, combine (Merge Sort, Quick Sort).</li>
            <li>Decrease & Conquer: Solve smaller instance and build up (Insertion Sort).</li>
            <li>Transform & Conquer: Simplify problem for efficiency (Binary Search).</li>
            <li>Greedy Algorithm: Locally optimal choices for global optimum (Huffman Coding).</li>
        </ul>

        <h4>Special Algorithms</h4>
        <ul>
            <li>Boyer-Moore / Rabin-Karp: Efficient string searching.</li>
            <li>Dijkstra / Floyd-Warshall: Shortest paths.</li>
            <li>Kruskal / Prim: Minimum Spanning Tree.</li>
            <li>Warshall: Transitive closure in graphs.</li>
        </ul>
    </div>

</body>
</html>
