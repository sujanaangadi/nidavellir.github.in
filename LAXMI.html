<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAXMI</title>

   <style>
/* ---------- NAVIGATION BAR --------- */
.navbar {
    width: 100%;
    background: #0A1A3A;
    padding: 20px 40px;
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 10;
}

.navbar .logo {
    font-size: 28px;
    font-weight: 700;
    color: white;
    margin-right: 40px;
}

.navbar ul {
    display: flex;
    list-style: none;
    gap: 25px;
    margin: 0;
    padding: 0;
}

.navbar ul li a {
    text-decoration: none;
    color: #C8D6FF;
    font-size: 18px;
    font-weight: 600;
    transition: 0.3s;
}

.navbar ul li a:hover {
    color: #00E5A8;
}

        /* ---------- PAGE CONTENT STYLING --------- */
        body {
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .content {
            width: 80%;
            background: #001f4d; /* Dark blue background */
            color: white; /* White text */
            margin: 40px auto;
            padding: 30px;
            border-radius: 10px;
            font-size: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .content h2, .content h3, .content h4 {
            color: #a0e1ff; /* Light blue headings for contrast */
        }

        .content ul, .content p {
            line-height: 1.6;
        }

        .content table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            color: white;
        }

        .content table th, .content table td {
            padding: 10px;
            border: 1px solid white;
        }

        .content table th {
            background-color: #003366;
        }

        .title-box {
            width: 80%;
            background: black;
            color: #3cb371;  
            font-size: 40px;
            font-weight: bold;
            margin: 180px auto 40px auto;
            text-align: center;
            padding: 20px;
            border-radius: 15px;
        }

        /* Optional: make links inside content stand out */
        .content a {
            color: #ffcc00;
            text-decoration: underline;
        }
    </style>
</head>

<body>

    <!-- ------------------ NAVBAR ------------------ -->
    <div class="navbar">
        <div class="logo">CITY DESIGN</div>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="project.html">Project</a></li>
            <li><a href="SHRAVANA.html">SHRAVANA</a></li>
            <li><a href="SUJANA.html">SUJANA</a></li>
            <li><a href="KHUSHI.html">KHUSHI</a></li>
            <li><a href="LAXMI.html">LAXMI</a></li>
            <li><a href="collabz.html">Collabz</a></li>
        </ul>
    </div>
<style>
  /* Light Mode (White Background) */
  :root{
    --bg:#ffffff;
    --card:#f5f7fa;
    --accent1:#008000;      /* green */
    --accent2:#0066cc;      /* blue */
    --muted:#333333;        /* dark gray */
    --glass: rgba(0,0,0,0.05);
  }

  *{box-sizing:border-box}

  body{
    margin:0;
    font-family:"Segoe UI", Roboto, Arial, sans-serif;
    background: #DDE8D1;                       /* Nude light green*/
    color:#222;                             /* dark text */
    padding-bottom:80px;
  }

  /* header */
  .header {
    position:fixed;
    left:0; right:0; top:0;
    height:72px;
    display:flex;
    align-items:center;
    gap:24px;
    padding:0 28px;
    background:#bdebff;                     /* light sky blue */
    border-bottom:1px solid #ddd;
    z-index:100;
  }

  .logo {
    color:#000;
    font-weight:800;
    font-size:22px;
  }

  .nav {
    margin-left:auto;
    display:flex;
    gap:18px;
  }
  .nav a{
    color:#000;
    font-weight:600;
    text-decoration:none;
  }

  /* layout */
  .container{
    max-width:1150px;
    margin:110px auto 40px;
    padding:20px;
  }

  .hero{
    display:flex;
    gap:28px;
    align-items:center;
    flex-wrap:wrap;
    margin-bottom:24px;
  }

  .hero h1{
    margin:0 0 8px 0;
    color:#008000;          /* green */
    font-size:38px;
    font-weight:800;
  }

  .hero img{
    width:330px;
    border-radius:14px;
    border:2px solid #00800020;
    box-shadow:0 6px 18px rgba(0,128,0,0.15);
  }

  /* Cards */
  .grid{
    display:grid;
    grid-template-columns:1fr;
    gap:18px;
  }
  @media(min-width:980px){
    .grid{grid-template-columns:1fr 1fr;}
  }

  .card{
    background:#f7f9fb;
    border-radius:14px;
    padding:18px;
    border:1px solid #ddd;
    box-shadow:0 4px 12px rgba(0,0,0,0.08);
  }

  .card h2{
    margin:0;
    color:#0066cc;
    font-size:20px;
  }

  .subtitle{
    color:#008000;
    font-weight:600;
    margin-bottom:10px;
  }

  .meta{
    font-size:15px;
    color:#444;
  }

  /* Button */
  .btn{
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    border:0;
    background:#008000;
    color:white;
    font-weight:700;
  }

  /* Algorithm box */
  .algo{
    display:none;
    background:#e8fff0;
    border:1px solid #00800055;
    border-radius:10px;
    padding:12px;
    margin-top:12px;
  }

  .algo pre{
    background:#ffffff;
    padding:10px;
    border-radius:8px;
    border:1px solid #ccc;
    color:#000;
    overflow:auto;
  }
</style>

  <main class="container">
    <section class="hero">
      <div class="title">
        <h1>Agriculture Business Ideas </h1>
      </div>

      <!-- change this image file name to your generated image -->
      <img src="Screenshot 2025-12-08 201150.png" alt="Smart agriculture image (place smart_agri_green.png here)">
    </section>

    <!-- grid of cards -->
    <section class="grid">

      <!-- 1 -->
      <article class="card">
        <h2>1) Coconut Husk Water-Reservation System</h2>
        <div class="subtitle">“Save 50% water using natural husk technology."</div>
        <div class="meta">
          <strong>A system that uses coconut husk fibers to hold water in the soil.</strong>.<br>
*Coconut husk acts like a sponge → stores water.<br>
*Helps plants survive during dry seasons.<br>
*Low cost, eco-friendly.<br>
          <strong>How to implement:</strong> Mix coconut husk (coir) with soil in beds or pits; use 20–30% coir ratio; mulch surface.<br>
          <strong> Benefits:</strong> Holds 8–10× water, reduces irrigation 40–60%, more yield.<br>
          <strong>Related SDGs:</strong>SDG 6,12,13.<br>
          <strong>Used algorithm and why:</strong>"A Greedy Algorithm "makes the best possible choice at each step, aiming to maximize water storage and minimize wastage. When applied to a coconut-husk water reservation system, it becomes the most effective technique for water distribution and absorption.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo1">Show Algorithm</button>
        </div>

        <div id="algo1" class="algo">
          <strong>Greedy Water Optimization </strong>
          <pre>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<pair<int,double>> sections = {{1,15.2},{2,25.5},{3,10},{4,30.1},{5,8.5},{6,20}};
    double threshold = 18.0;

    sort(sections.begin(), sections.end(), [](auto &a, auto &b){ return a.second < b.second; });

    for(auto &s : sections) {
        if(s.second < threshold) 
            cout << "Section " << s.first << ": Apply coir & minimal irrigation\n";
        else 
            cout << "Section " << s.first << ": Skip\n";
    }
}

</pre>
        </div>
      </article>

      <!-- 2 -->
      <article class="card">
        <h2>2) Organic Vegetable Farming</h2>
        <div class="subtitle">“Farm-to-family delivery within 3 hours.”</div>
        <div class="meta">
          <strong>How to implement:</strong> *Sell vegetables directly to apartments, schools, gyms, hotels.<br>
            <strong>why It Works:</strong>
*People want chemical-free food.<br>
*Tie-up with Swiggy/Zomato → guaranteed sales.<br>
*Subscription model → monthly income.<br>
          <strong>Benefits:</strong> Healthier produce & higher price (≈2×), local employment.<br>
          <strong>Related SDGs:</strong>SDG 2,3,12 .<br>
          <strong>Used algorithm and why</strong>"Dynamic Programming "(DP) is a technique for solving complex, multi-step agricultural decisions by breaking them into smaller optimized stages.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo2">Show Algorithm</button>
        </div>

        <div id="algo2" class="algo">
          <strong>Dynamic Programming: Crop & Fertilizer Scheduling </strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

int main() {
    int days=10, crops=3;
    vector<double> DP(crops,0), prev(crops,0);
    vector<int> choice(days*crops,-1);

    auto benefit=[](int c,int d){ return 10+c*2-0.1*d; };
    auto cost=[](int c,int d){ return 5+0.5*c; };

    for(int d=1; d<=days; d++){
        prev=DP;
        for(int c=0; c<crops; c++){
            double maxY=-1e9;
            for(int p=0; p<crops; p++)
                if(prev[p]+benefit(c,d)-cost(c,d)>maxY){
                    maxY=prev[p]+benefit(c,d)-cost(c,d);
                    choice[d*crops+c]=p;
                }
            DP[c]=maxY;
        }
    }

    double maxTotal=-1e9; int last=-1;
    for(int c=0;c<crops;c++) if(DP[c]>maxTotal){ maxTotal=DP[c]; last=c; }

    vector<int> rotation(days);
    for(int d=days; d>=1; d--){ rotation[d-1]=last; last=choice[d*crops+last]; }

    cout<<"Max yield: "<<maxTotal<<"\nCrop rotation:\n";
    for(int d=0;d<days;d++) cout<<"Day "<<d+1<<": Crop "<<rotation[d]<<"\n";
}

        </div>
      </article>

      <!-- 3 -->
      <article class="card">
        <h2>3) Mushroom Cultivation</h2>
        <div class="subtitle">“Protein Manufacturing in Small Spaces”</div>
        <div class="meta">
           <strong> Convert a small room into a protein factory.</strong>

<strong>Why It Works:</strong>
*Mushrooms grow in 25 days → fast cash flow.<br>
*Hotels, bakeries, hostels need mushrooms daily.<br>
*Value-added products: mushroom pickle, powder.<br>
          <strong>How to implement:</strong> Build humid shed; use straw/waste + spawn; control humidity and harvesting cycles.<br>
          <strong>Benefits:</strong> Fast cycles (30–35 days), women-friendly, high margin.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo3">Show Algorithm</button>
        </div>

        <div id="algo3" class="algo">
          <strong>Kruskal-like Cost Minimization</strong>
          <pre>
              #include <bits/stdc++.h>
using namespace std;

int main() {
    double budget = 50000, cost = 0;
    vector<string> need = {"shed","spawn","straw"}, pick;
    vector<pair<string,int>> items = {
        {"shed",15000},{"spawn",5000},{"straw",3000},{"humidifier",7000},{"trays",4000}
    };

    sort(items.begin(), items.end(), [](auto &a, auto &b){ return a.second < b.second; });

    for (auto &x : items) {
        pick.push_back(x.first); cost += x.second;
        bool ok = true;
        for (auto &n : need)
            if (find(pick.begin(), pick.end(), n) == pick.end()) ok = false;
        if (ok) break;
    }

    if (cost <= budget) {
        cout << "Items:\n";
        for (auto &x : pick) cout << x << "\n";
        cout << "Cost = " << cost;
    } else cout << "Budget exceeded!";
}
</pre>
        </div>
      </article>
      <!-- 4 -->
      <article class="card">
        <h2>4) Hydroponic Farming</h2>
        <div class="subtitle">“Cleanest vegetables in the city – guaranteed.”</div>
        <div class="meta">
          <strong>How to implement:</strong> *Sell premium salad greens to urban customers at 3× price.<br>
            *Metro cities love hydroponic food.<br>
            *Zero pesticides → very high demand.<br>
            *Can build rooftop farms on buildings, offices, restaurants.<br>
            *Use NFT/DWC systems, nutrient solution, pumps, and monitoring.<br>
          <strong>Benefits:</strong> Faster growth, 80–90% less water, premium produce.<br>
         <strong>SDGs:</strong>SDG  2,6,9,11.<br>
            <strong>Used algorithm and why</strong>"Dynamic Programming" ensures the most efficient nutrient, water, and growth-cycle scheduling in hydroponic farming for maximum yield with minimum cost.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo4">Show Algorithm</button>
        </div>

        <div id="algo4" class="algo">
          <strong>Dynamic Programming</strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

int main() {
    const int DAYS = 7, N = 101;
    int DP[2][N] = {};
    auto growth = [](int n){ return n*2; };

    for(int n=0;n<N;n++) DP[0][n]=growth(n);

    for(int day=1;day<=DAYS;day++){
        for(int nut=0;nut<N;nut++){
            int best=0;
            for(int prev=max(0,nut-10);prev<=min(100,nut+10);prev++)
                best=max(best,DP[(day-1)%2][prev]+growth(nut));
            DP[day%2][nut]=best;
        }
    }

    int res=0; for(int n=0;n<N;n++) res=max(res,DP[DAYS%2][n]);
    cout<<"Max growth: "<<res<<"\n";
}

</pre>
        </div>
      </article>

      <!-- 5 -->
      <article class="card">
        <h2>5) Dairy + Cow-Dung Products</h2>
        <div class="subtitle">“Eco-friendly products from pure desi cow origin.”</div>
        <div class="meta">
          <strong>How to implement:</strong> *Rajasthan has huge cattle population.<br>
                *Plenty of raw cow dung available for eco-products.<br>
                *High demand during festivals and tourism markets.<br>
               * Collect milk; small chilling; convert dung to manure, diyas, incense.<br>
          <strong>Benefits:</strong> Daily cashflow, zero waste, women-led units.<br>
         <strong>SDGs:</strong>SDG  7,12,8.<br>
         <strong>Used algorithm and why</strong>"Max-Heap Priority Scheduling" ensures we always produce the highest-profit, highest-demand cow-dung products first, maximizing revenue and minimizing waste.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo5">Show Algorithm</button>
        </div>

        <div id="algo5" class="algo">
          <strong>Max-Heap Priority Scheduling (pseudocode)</strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

struct Cow {
    int id, milkYield;
    bool operator<(const Cow &c) const { return milkYield < c.milkYield; }
};

int main() {
    vector<Cow> cows = {{1,8},{2,12},{3,10}}; // id, expected milk
    priority_queue<Cow> H(cows.begin(), cows.end());

    while(!H.empty()) {
        Cow c = H.top(); H.pop();
        cout << "Milking cow " << c.id << " with yield " << c.milkYield << endl;
        c.milkYield = max(0, c.milkYield - 2); // update yield for next round
        if(c.milkYield > 0) H.push(c);
    }
}

</pre>
        </div>
      </article>

      <!-- 6 -->
      <article class="card">
        <h2>6) Beekeeping (Honey Production)</h2>
        <div class="subtitle">“A multi-product natural enterprise with strong global demand.”</div>
        <div class="meta">
          <strong>How to implement:</strong>*Aravalli hills support wild flora → ideal for natural honey.<br>
                *Jawai region has Neem, Acacia, Ber, perfect for floral honey.<br>
                *Resorts love local “forest honey” branding.<br>
               * Install boxes in flowering areas; seasonal management & extraction.<br>
          <strong>Benefits:</strong> Good margins, crop pollination increase, low CAPEX.<br>
            <strong>SDGs:</strong>SDG 15,8,2.<br>
            <strong>Used algorithm and why</strong>"DFS" is ideal for beekeeping because it maps deep hive-to-flower foraging paths efficiently, helping identify the longest and most productive nectar routes.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo6">Show Algorithm</button>
        </div>

        <div id="algo6" class="algo">
          <strong>DFS For Hive Foraging Paths </strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

vector<int> G[5]; bool v[5];

void DFS(int u){
    v[u]=1; cout<<"Nectar at "<<u<<"\n";
    for(int x:G[u]) if(!v[x]) DFS(x);
}

int main(){
    G[0]={1,2}; G[1]={0,3}; G[2]={0,4}; G[3]={1}; G[4]={2};
    DFS(0); // start from hive
}

</pre>
        </div>
      </article>

      <!-- 7 -->
      <article class="card">
        <h2>7) Nursery Business (Plants & Saplings)</h2>
        <div class="subtitle">"Green gifts that stay alive.”</div>
        <div class="meta">
          <strong>How to implement:</strong>* Hotels, resorts, farmhouses near Jawai safari demand landscaping.<br>
                 *Government pushes plantation drives in Aravalli hills.<br>
                 *Urban homes in Pali, Abu Road, Sumerpur want indoor plants.<br>
                 *Shade net area, seed trays, potting mix, drip watering, small staff.<br>
          <strong>Benefits:</strong> Year-round revenue, supports reforestation & orchards.<br>
          <strong>SDGs</strong>SDG 15,11,13.<br>
            <strong>Used algorithm and why</strong>"Segment Tree "allows ultra-fast category-wise plant stock, price, and demand queries, making nursery business management efficient and scalable.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo7">Show Algorithm</button>
        </div>

        <div id="algo7" class="algo">
          <strong>Segment Tree  </strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

vector<int> seg;
int n;

void build(vector<int> &a) {
    n = a.size();
    seg.assign(4*n, 0);
    function<void(int,int,int)> make = [&](int node, int l, int r){
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l+r)/2;
        make(node*2, l, mid);
        make(node*2+1, mid+1, r);
        seg[node] = seg[node*2] + seg[node*2+1];
    };
    make(1, 0, n-1);
}

int query(int node, int l, int r, int ql, int qr) {
    if (qr < l || ql > r) return 0;
    if (ql <= l && r <= qr) return seg[node];
    int mid = (l+r)/2;
    return query(node*2, l, mid, ql, qr) +
           query(node*2+1, mid+1, r, ql, qr);
}

int main() {
    vector<int> plants = {5, 3, 2, 7, 4};
    build(plants);
    cout << "Stock (Category 1 to 4) = "
         << query(1, 0, plants.size()-1, 1, 4);
}


</pre>
        </div>
      </article>

      <!-- 8 -->
      <article class="card">
        <h2>8) Medicinal Plant Farming</h2>
        <div class="subtitle">“A secure contract-farming model supplying the booming global herbal market.”</div>
        <div class="meta">
          <strong>How to implement:</strong> *Guaranteed buy-back contracts from pharma companies.<br>
                      *High-value crops like Ashwagandha, Giloy, Aloevera.<br>
                     *Export potential for herbal raw materials.<br>
                    *Select drought-tolerant species, prepare beds, minimal irrigation, harvest & dry.<br>
          <strong>Benefits:</strong> High demand from pharma & Ayurveda; low water need.<br>
          <strong>SDGs:</strong> SDS 3,12,8.<br>
          <strong>Used algorithm and why</strong>"BST "keeps medicinal plant batches sorted by harvest date, allowing fast insertion, search, and selection of the next batch to harvest<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo8">Show Algorithm</button>
        </div>

        <div id="algo8" class="algo">
          <strong>BST: Batch Tracking & Harvest Order</strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

struct Node{int date; Node *l,*r; Node(int d):date(d),l(0),r(0){};};
Node* insert(Node* root,int d){ 
    if(!root) return new Node(d);
    if(d<root->date) root->l=insert(root->l,d);
    else root->r=insert(root->r,d);
    return root;
}
Node* removeMax(Node* root){ 
    if(!root->r) return root->l;
    root->r=removeMax(root->r); return root;
}
void inorder(Node* root){ 
    if(!root) return; inorder(root->l); cout<<root->date<<" "; inorder(root->r);
}

int main(){
    Node* root=0;
    root=insert(root,5); root=insert(root,2); root=insert(root,8);
    cout<<"Batches in age order: "; inorder(root); cout<<"\n";
    root=removeMax(root); // harvest oldest
    cout<<"After harvest: "; inorder(root);
}

</pre>
        </div>
      </article>

      <!-- 9 -->
      <article class="card">
        <h2>9) Solar Farming</h2>
        <div class="subtitle">"Small solar plant on unused land"</div>
        <div class="meta">
          <strong>How to implement:</strong> *Rent out land to solar companies → fixed income for 25–30 years.<br>
            *Extremely low maintenance.<br>
            *Strong government subsidies & green investment opportunities.<br>
            * Install panels, inverter, net-metering or sell to nearby grid.<br>
          <strong>Benefits:</strong> Passive income, reduces electricity cost.<br>
          <strong>SDGs:</strong>SDG 7,13,9.<br>
            <strong>Uesd algorithm and why</strong>"Prim’s MST "gives the minimum-cost wiring layout for solar panels, reducing cable length, power loss, and installation expenses.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo9">Show Algorithm</button>
        </div>

        <div id="algo9" class="algo">
          <strong>Prim's MST for Wiring & Layout</strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;
const int INF=1e9;

int main(){
    int n=4; // panels
    int cost[4][4]={
        {0,2,3,INF},
        {2,0,15,2},
        {3,15,0,13},
        {INF,2,13,0}
    };
    vector<int> key(n,INF), parent(n,-1);
    vector<bool> inMST(n,false);
    key[0]=0;

    for(int i=0;i<n-1;i++){
        int u=-1;
        for(int v=0;v<n;v++) if(!inMST[v]&&(u==-1||key[v]<key[u])) u=v;
        inMST[u]=true;
        for(int v=0;v<n;v++) if(cost[u][v]<key[v]&&!inMST[v]) {key[v]=cost[u][v]; parent[v]=u;}
    }

    cout<<"Wiring layout:\n";
    for(int i=1;i<n;i++) cout<<parent[i]<<" - "<<i<<" : "<<cost[i][parent[i]]<<"\n";
}

</pre>
        </div>
      </article>

      <!-- 10 -->
      <article class="card">
        <h2>10) Smart Goat Farming Unit</h2>
        <div class="subtitle">“Tech-enabled goat farming with 40% higher profit.”</div>
        <div class="meta">
          <strong>How to implement:</strong> *Create a “Smart Goat Farm Model” and sell training + kids (baby goats).<br>
               * Smart-fed goats grow faster → high-profit meat.<br>
               *we can sell goat milk, manure, and goat kids.<br>
                *Training makes extra income.<br>
            *Build ventilated shed, buy quality kids, vaccination & feeding schedule.<br>
          <strong>Benefits:</strong> Quick breeding, small land, year-round income.<br>
          <strong>SDGs:</strong>SDG 2,8,93.<br>
            <strong>Used algorithm and why</strong>"Binary Search" enables instant retrieval of goat health records from sorted data, ensuring fast diagnosis and efficient farm management.<br>
        </div>

        <div class="row">
          <button class="btn" data-algo="algo10">Show Algorithm</button>
        </div>

        <div id="algo10" class="algo">
          <strong>Binary Search for Health Record Lookup </strong>
          <pre>
#include <bits/stdc++.h>
using namespace std;

struct Record{ int date; string info; };
Record* findRecord(vector<Record>& recs, int d){
    int l=0, r=recs.size()-1;
    while(l<=r){
        int m=(l+r)/2;
        if(recs[m].date==d) return &recs[m];
        else if(recs[m].date<d) l=m+1;
        else r=m-1;
    }
    return nullptr;
}

int main(){
    vector<Record> health={{20250101,"Vaccinated"},{"20250301","Dewormed"},{"20250401","Checkup"}};
    int query=20250301;
    Record* r=findRecord(health,query);
    if(r) cout<<"Found: "<<r->info;
    else cout<<"No record";
}

</pre>
        </div>
      </article>

    </section>

    <footer>
    </footer>
  </main>

  <script>
    // Toggle algorithms
    document.querySelectorAll('.btn').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const id = btn.getAttribute('data-algo');
        const panel = document.getElementById(id);
        if(!panel) return;
        // toggle open/close and change button text
        if(panel.style.display === 'block'){
          panel.style.display = 'none';
          btn.textContent = 'Show Algorithm';
        } else {
          // close any other open panels
          document.querySelectorAll('.algo').forEach(a => a.style.display = 'none');
          document.querySelectorAll('.btn').forEach(b => b.textContent = 'Show Algorithm');
          panel.style.display = 'block';
          btn.textContent = 'Hide Algorithm';
          // scroll into view smoothly
          panel.scrollIntoView({behavior:'smooth', block:'center'});
        }
      });
    });

    // close algorithm panels when Escape pressed
    document.addEventListener('keydown', e=>{
      if(e.key === 'Escape'){
        document.querySelectorAll('.algo').forEach(a=> a.style.display='none');
        document.querySelectorAll('.btn').forEach(b=> b.textContent='Show Algorithm');
      }
    });
  </script>
</body>
</html>
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Ideas Table</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="content">
            <h2>Agriculture Business Ideas – Investment & Profit</h2>
            <table>
                <thead>
                    <tr>
                        <th>Idea</th>
                        <th>Investment</th>
                        <th>Profit/Year</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Coconut Husk Pits</td>
                        <td>₹10k–15k</td>
                        <td>₹15k–25k</td>
                    </tr>
                    <tr>
                        <td>Organic Vegetables</td>
                        <td>₹25k–40k</td>
                        <td>₹1.5–2.5 lakh</td>
                    </tr>
                    <tr>
                        <td>Mushroom Farming</td>
                        <td>₹20k–40k</td>
                        <td>₹80k–1.2 lakh</td>
                    </tr>
                    <tr>
                        <td>Hydroponic</td>
                        <td>₹70k–1 lakh</td>
                        <td>₹1.5–2.4 lakh</td>
                    </tr>
                    <tr>
                        <td>Dairy Farming</td>
                        <td>₹1.3–1.5 lakh</td>
                        <td>₹1–1.5 lakh</td>
                    </tr>
                    <tr>
                        <td>Cow Dung Products</td>
                        <td>₹25k–40k</td>
                        <td>₹2–3 lakh</td>
                    </tr>
                    <tr>
                        <td>Beekeeping</td>
                        <td>₹30k</td>
                        <td>₹60k–1 lakh</td>
                    </tr>
                    <tr>
                        <td>Nursery</td>
                        <td>₹20k–50k</td>
                        <td>₹60k–1.5 lakh</td>
                    </tr>
                    <tr>
                        <td>Medicinal Plants</td>
                        <td>₹15k–25k</td>
                        <td>₹80k–1.5 lakh</td>
                    </tr>
                    <tr>
                        <td>Goat Farming</td>
                        <td>₹80k</td>
                        <td>₹40k–60k</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</body>
</html>

    <!-- MAIN TITLE -->
    <div class="title-box">DESIGN & ANALYSIS OF ALGORITHMS</div>

    <!-- ------------------ SECTION 1 ------------------ -->
    <div class="content">
        <h2>What is the course about?</h2>
        <p>The Design and Analysis of Algorithms (DAA) course is about developing a deep understanding of how algorithms work, how they are designed, and how they can be optimized for efficiency.</p>
        <ul>
            <li>The systematic design of algorithms</li>
            <li>Time & space complexity</li>
            <li>Greedy, Divide-and-Conquer, Dynamic Programming</li>
            <li>Graph algorithms</li>
            <li>Optimization techniques</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 2 ------------------ -->
    <div class="content">
        <h3>Connection with the real world</h3>
        <p><strong>What data structures and algorithms did I study?</strong></p>
        <p>During the course I explored a variety of data structures and algorithms, including:</p>

        <div style="display:flex;gap:40px;flex-wrap:wrap;">
            <div style="min-width:240px">
                <h4>Data Structures</h4>
                <ul>
                    <li>Arrays, Linked Lists</li>
                    <li>Stacks, Queues</li>
                    <li>Trees, Graphs</li>
                    <li>Hash Tables</li>
                </ul>
            </div>

            <div style="min-width:240px">
                <h4>Algorithms</h4>
                <ul>
                    <li>Sorting: Merge Sort, Quick Sort</li>
                    <li>Graph: Dijkstra’s, Kruskal’s</li>
                    <li>String matching: Rabin–Karp, Boyer–Moore</li>
                </ul>
            </div>
        </div>

        <p>This course is an essential foundation for software engineering, competitive programming, and machine learning — it builds efficient problem-solving skills.</p>
    </div>

    <!-- ------------------ SECTION 3 ------------------ -->
    <div class="content">
        <h3>Course Reflections</h3>

        <h4>1. Natural Problem Patterns</h4>
        <p><strong>Iteration</strong></p>
        <ul>
            <li>Daily routine</li>
            <li>Game turns</li>
            <li>Practice loops</li>
        </ul>

        <p><strong>Recursion</strong></p>
        <ul>
            <li>Tree growth</li>
            <li>Fractal patterns</li>
            <li>Nested structures</li>
        </ul>

        <p><strong>Backtracking</strong></p>
        <ul>
            <li>Finding locations</li>
            <li>Sudoku solving</li>
            <li>Trying alternatives</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 4 ------------------ -->
    <div class="content">
        <h3>Time & Space Efficiency</h3>
        <p>Algorithms are measured by how efficiently they use time and memory. Time complexity measures the number of operations, while space complexity measures memory usage.</p>

        <table>
            <thead>
                <tr>
                    <th>Order</th>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>O(1)</td>
                    <td>Constant</td>
                    <td>Minimal</td>
                    <td>Accessing array element</td>
                </tr>
                <tr>
                    <td>O(log n)</td>
                    <td>Logarithmic</td>
                    <td>Low</td>
                    <td>Binary search</td>
                </tr>
                <tr>
                    <td>O(n)</td>
                    <td>Linear</td>
                    <td>Moderate</td>
                    <td>Linear search</td>
                </tr>
                <tr>
                    <td>O(n²)</td>
                    <td>Quadratic</td>
                    <td>High</td>
                    <td>Bubble sort</td>
                </tr>
                <tr>
                    <td>O(2ⁿ)</td>
                    <td>Exponential</td>
                    <td>Very High</td>
                    <td>Brute-force TSP</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- ------------------ SECTION 5 ------------------ -->
    <div class="content">
        <h3>Hierarchical Data & Tree Structures</h3>
        <table>
            <thead>
                <tr>
                    <th>Tree Type</th>
                    <th>Best For</th>
                    <th>Strength</th>
                    <th>Limitation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>BST</td>
                    <td>Sorted data, moderate updates</td>
                    <td>Simple structure</td>
                    <td>Can become unbalanced</td>
                </tr>
                <tr>
                    <td>AVL Tree</td>
                    <td>Frequent lookups</td>
                    <td>Guaranteed balance</td>
                    <td>Costly rotations</td>
                </tr>
                <tr>
                    <td>2-3 Tree</td>
                    <td>Predictable performance</td>
                    <td>Consistent height</td>
                    <td>Implementation complexity</td>
                </tr>
                <tr>
                    <td>Red-Black Tree</td>
                    <td>Dynamic datasets</td>
                    <td>Fewer rotations</td>
                    <td>Slightly less balanced</td>
                </tr>
                <tr>
                    <td>Heap</td>
                    <td>Priority-based operations</td>
                    <td>Efficient min/max</td>
                    <td>Not for general search</td>
                </tr>
                <tr>
                    <td>Trie</td>
                    <td>Strings & prefix searches</td>
                    <td>Fast prefix search</td>
                    <td>High memory usage</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- ------------------ SECTION 6 ------------------ -->
    <div class="content">
        <h3>Array Query Algorithms</h3>
        <p><strong>Principles:</strong> Divide and conquer, dynamic programming, optimization.</p>
        <p><strong>Purpose:</strong> Efficiently retrieve, manipulate, or analyze large datasets.</p>
        <ul>
            <li>Binary Index Tree: O(log n), for sorted arrays.</li>
            <li>Sliding Window: O(n), for overlapping subarray analysis.</li>
            <li>Segment Tree: O(log n), for range queries.</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 7 ------------------ -->
    <div class="content">
        <h3>Trees and Graphs</h3>
        <p><strong>Difference:</strong></p>
        <ul>
            <li>Tree: Hierarchical, no cycles. Example: File system.</li>
            <li>Graph: Can have cycles, flexible connections. Example: City map.</li>
        </ul>

        <p><strong>Tree Traversals:</strong></p>
        <ul>
            <li>In-Order: Left → Node → Right (sorting)</li>
            <li>Pre-Order: Node → Left → Right (copying)</li>
            <li>Post-Order: Left → Right → Node (deletion)</li>
            <li>Level-Order (BFS): Visit nodes level by level</li>
        </ul>

        <p><strong>Graph Traversals:</strong></p>
        <ul>
            <li>DFS: Go deep before backtracking (maze solving)</li>
            <li>BFS: Explore level by level (shortest paths)</li>
        </ul>

        <p><strong>Applications:</strong></p>
        <ul>
            <li>Trees: File systems, decision trees, databases</li>
            <li>Graphs: Social networks, GPS navigation, web crawlers</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 8 ------------------ -->
    <div class="content">
        <h3>Sorting & Searching Algorithms</h3>
        <h4>Sorting</h4>
        <ul>
            <li>Bubble Sort: Swap adjacent items. Small datasets.</li>
            <li>Selection Sort: Pick smallest each time. Minimizes swaps.</li>
            <li>Insertion Sort: Insert items in correct position. Nearly sorted data.</li>
            <li>Merge Sort: Divide and merge. Large datasets.</li>
            <li>Quick Sort: Pivot-based divide. Fast for large data.</li>
            <li>Heap Sort: Uses heap structure. Efficient for priority queues.</li>
        </ul>
        <h4>Searching</h4>
        <ul>
            <li>Linear Search: Check each item sequentially.</li>
            <li>Binary Search: Divide and conquer on sorted data.</li>
            <li>BFS/DFS: Shortest path or complete exploration in graphs.</li>
        </ul>
    </div>

    <!-- ------------------ SECTION 9 ------------------ -->
    <div class="content">
        <h3>Graph Algorithms: Shortest Paths & Spanning Trees</h3>
        <table>
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Purpose</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Dijkstra</td>
                    <td>Single-source shortest path</td>
                    <td>Weighted graphs, navigation</td>
                </tr>
                <tr>
                    <td>Floyd-Warshall</td>
                    <td>All-pairs shortest paths</td>
                    <td>Dense graphs</td>
                </tr>
                <tr>
                    <td>Prim</td>
                    <td>Minimum Spanning Tree</td>
                    <td>Network design</td>
                </tr>
                <tr>
                    <td>Kruskal</td>
                    <td>Minimum Spanning Tree</td>
                    <td>Cost optimization</td>
                </tr>
                <tr>
                    <td>Bellman-Ford</td>
                    <td>Shortest paths with negative weights</td>
                    <td>Graphs with negative edges</td>
                </tr>
            </tbody>
        </table>

        <h3>Algorithm Design Techniques</h3>
        <ul>
            <li>Brute Force: Try all solutions. Simple but slow.</li>
            <li>Divide & Conquer: Split, solve, combine (Merge Sort, Quick Sort).</li>
            <li>Decrease & Conquer: Solve smaller instance and build up (Insertion Sort).</li>
            <li>Transform & Conquer: Simplify problem for efficiency (Binary Search).</li>
            <li>Greedy Algorithm: Locally optimal choices for global optimum (Huffman Coding).</li>
        </ul>

        <h4>Special Algorithms</h4>
        <ul>
            <li>Boyer-Moore / Rabin-Karp: Efficient string searching.</li>
            <li>Dijkstra / Floyd-Warshall: Shortest paths.</li>
            <li>Kruskal / Prim: Minimum Spanning Tree.</li>
            <li>Warshall: Transitive closure in graphs.</li>
        </ul>
    </div>

</body>
</html>
