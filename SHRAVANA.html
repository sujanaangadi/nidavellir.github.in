<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI POWERHOUSE & RENEWABLE ENERGY — Ideas + Algorithms (HTML)</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#00c2a8;--muted:#94a3b8;--glass:rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071428 0%, #07192b 60%);color:#e6eef6;padding:28px}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;gap:16px;margin-bottom:20px}
    h1{font-size:20px;margin:0}
    p.lead{margin:0;color:var(--muted)}
    .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;margin-top:18px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    .card h2{margin:0 0 8px 0;font-size:16px;color:var(--accent)}
    .meta{color:var(--muted);font-size:13px;margin-bottom:10px}
    pre{background:var(--glass);padding:12px;border-radius:8px;overflow:auto;color:#dffcf0;font-size:13px;margin:8px 0}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono',Courier New,monospace}
    .alg{margin:8px 0 12px 0}
    .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer;font-weight:600}
    .full{grid-column:1/ -1}
    footer{margin-top:22px;color:var(--muted);font-size:13px}
    .code-toggle{display:none}
    .code-panel{display:none;margin-top:8px}
    .code-panel.show{display:block}
    .card-controls{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;padding:6px 8px}
    .search{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);margin-bottom:12px}
    @media (max-width:880px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>AI Powerhouse & Renewable Energy — Ideas + Algorithms</h1>
        <p class="lead">Click "View Code" on any idea to reveal implementation (data structures & algorithms included). Code is hidden by default.</p>
      </div>
    </header>

    <input class="search" id="search" placeholder="Search idea or algorithm (e.g. Dijkstra, quicksort, battery)" />

    <div class="grid" id="grid">
      <!-- Reuse the 15 idea cards, each with a hidden code panel that opens when clicked -->

      <!-- Example card 1 with extended code -->
      <section class="card" data-title="AI Smart Power Distribution Controller">
        <h2>1. AI Smart Power Distribution Controller</h2>
        <div class="meta">Decides how much power to send to homes, factories & EV stations based on demand.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Collect demand from residential + industrial areas.</li>
            <li>Check current solar + wind + powerhouse generation.</li>
            <li>Distribute supply where demand &gt; priority.</li>
            <li>Prevent overload using threshold control.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code>// Business logic (Python-style)
class PowerDistributor:
    def __init__(self, batteries, nodes):
        self.batteries = batteries
        self.nodes = nodes

    def distribute(self, demands, generation):
        total_energy = generation['solar'] + generation['wind'] + generation['powerhouse'] + self.available_battery()
        # Priority: hospitals > industry > homes > EV
        order = ['hospitals','industry','homes','ev']
        allocation = {}
        for k in order:
            need = demands.get(k,0)
            give = min(need, total_energy)
            allocation[k] = give
            total_energy -= give
        return allocation

    def available_battery(self):
        return sum(b.charge for b in self.batteries)

# Example usage
# pd = PowerDistributor(batteries, nodes)
// end
</code></pre>
        </div>
      </section>

      <!-- Card 2: Solar Analyzer + includes quicksort as helper to rank panels by efficiency -->
      <section class="card" data-title="Solar Panel Efficiency Analyzer">
        <h2>2. Solar Panel Efficiency Analyzer</h2>
        <div class="meta">AI analyzes solar panels on each house and predicts cleaning/repair dates.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Read solar output from each house daily.</li>
            <li>Compare with expected output based on sunlight.</li>
            <li>If efficiency drops → send alert to schedule maintenance.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Rank panels by efficiency (Python)
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x['eff'] < pivot['eff']]
    mid = [x for x in arr if x['eff'] == pivot['eff']]
    right = [x for x in arr if x['eff'] > pivot['eff']]
    return quicksort(left) + mid + quicksort(right)

# Efficiency check
for house in houses:
    expected = predict_expected(house['location'], date)
    eff = house['actual_output'] / expected * 100
    if eff < 75:
        schedule_maintenance(house['id'])

# end
</code></pre>
        </div>
      </section>

      <!-- Card 3: Wind Turbine RPM Controller + HeapSort example -->
      <section class="card" data-title="Wind Turbine Smart RPM Controller">
        <h2>3. Wind Turbine Smart RPM Controller</h2>
        <div class="meta">Adjusts blade angle automatically to get maximum output from wind speed.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Read wind speed every second.</li>
            <li>Predict best RPM using regression model.</li>
            <li>Change blade angle to achieve predicted RPM.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Heap sort (useful to prioritize turbines by performance)
def heapify(a, n, i):
    largest = i
    l = 2*i + 1
    r = 2*i + 2
    if l < n and a[l] > a[largest]:
        largest = l
    if r < n and a[r] > a[largest]:
        largest = r
    if largest != i:
        a[i], a[largest] = a[largest], a[i]
        heapify(a, n, largest)

def heapsort(a):
    n = len(a)
    for i in range(n//2 - 1, -1, -1):
        heapify(a, n, i)
    for i in range(n-1, 0, -1):
        a[0], a[i] = a[i], a[0]
        heapify(a, i, 0)

# end
</code></pre>
        </div>
      </section>

      <!-- Card 4: Battery Optimization + Dijkstra (for routing energy through microgrid graph) -->
      <section class="card" data-title="AI-Based Battery Storage Optimization">
        <h2>4. AI-Based Battery Storage Optimization</h2>
        <div class="meta">Stores extra solar/wind energy in batteries and uses it during peak hours.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Monitor grid load.</li>
            <li>If generation &gt; demand → charge battery.</li>
            <li>If demand &gt; generation → discharge battery.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Dijkstra for finding lowest-loss path between nodes in microgrid
import math

def dijkstra(graph, source):
    # graph: {node: [(neighbor, weight), ...]}
    dist = {v: math.inf for v in graph}
    prev = {v: None for v in graph}
    dist[source] = 0
    Q = set(graph.keys())
    while Q:
        u = min(Q, key=lambda x: dist[x])
        Q.remove(u)
        for v, w in graph[u]:
            alt = dist[u] + w
            if alt < dist[v]:
                dist[v] = alt
                prev[v] = u
    return dist, prev

# Use to route energy where transmission losses are smallest
# end
</code></pre>
        </div>
      </section>

      <!-- Card 5: Power Theft Detection + Rabin-Karp for pattern matching in usage time-series -->
      <section class="card" data-title="Power Theft Illegal Connection Detection">
        <h2>5. Power Theft / Illegal Connection Detection</h2>
        <div class="meta">Detects electricity theft using abnormal usage patterns.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Compare billed usage vs sensor usage.</li>
            <li>Sudden spikes → mark suspicious.</li>
            <li>Send report to grid admin.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Rabin-Karp to find suspicious repeated patterns in usage
def rabin_karp(text, pattern, base=256, mod=101):
    n, m = len(text), len(pattern)
    if m > n:
        return []
    h = pow(base, m-1, mod)
    p_hash = 0
    t_hash = 0
    res = []
    for i in range(m):
        p_hash = (base*p_hash + ord(pattern[i])) % mod
        t_hash = (base*t_hash + ord(text[i])) % mod
    for i in range(n-m+1):
        if p_hash == t_hash and text[i:i+m] == pattern:
            res.append(i)
        if i < n-m:
            t_hash = (base*(t_hash - ord(text[i])*h) + ord(text[i+m])) % mod
            if t_hash < 0:
                t_hash += mod
    return res

# end
</code></pre>
        </div>
      </section>

      <!-- Card 6: Emergency Auto-Switching + BFS/DFS examples for system checks -->
      <section class="card" data-title="Energy Emergency Auto-Switching">
        <h2>6. Energy Emergency Auto-Switching</h2>
        <div class="meta">During storms or grid failure, system switches supply to stored battery energy.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Monitor grid voltage.</li>
            <li>If voltage &lt; danger limit → disconnect grid.</li>
            <li>Switch to local battery / backup storage.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># BFS for health-check propagation across devices
from collections import deque

def bfs_check(graph, start):
    visited = set([start])
    q = deque([start])
    results = []
    while q:
        u = q.popleft()
        results.append(u)
        for v in graph.get(u,[]):
            if v not in visited:
                visited.add(v)
                q.append(v)
    return results

# end
</code></pre>
        </div>
      </section>

      <!-- Card 7: Demand Predictor + Time-series smoothing example (moving average) -->
      <section class="card" data-title="City-Wide Energy Demand Predictor">
        <h2>7. City-Wide Energy Demand Predictor</h2>
        <div class="meta">Predicts next day’s power need based on weather + factory workload + temperature.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Take historical demand database.</li>
            <li>Train time-series ML model.</li>
            <li>Predict future peak load.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Simple moving average forecast
def moving_average(series, window=3):
    return [sum(series[i:i+window])/window for i in range(len(series)-window+1)]

# Example: predicted_load = moving_average(past_24_hours, window=3)[-1]
# end
</code></pre>
        </div>
      </section>

      <!-- Card 8: Price Optimizer + Binary Search for pricing tiers -->
      <section class="card" data-title="Real-Time Electricity Price Optimizer">
        <h2>8. Real-Time Electricity Price Optimizer</h2>
        <div class="meta">AI adjusts electricity charges depending on peak and off-peak hours.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>If demand → high → price increases slightly.</li>
            <li>If demand → low → reduced pricing.</li>
            <li>Notify user via app.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Binary search to find price tier by usage
def find_tier(tiers, usage):
    # tiers: sorted list of (limit, price)
    lo, hi = 0, len(tiers)-1
    while lo <= hi:
        mid = (lo+hi)//2
        if usage <= tiers[mid][0]:
            hi = mid-1
        else:
            lo = mid+1
    return tiers[lo] if lo < len(tiers) else tiers[-1]

# end
</code></pre>
        </div>
      </section>

      <!-- Card 9: Peer-to-Peer Grid + Hash Table for credits -->
      <section class="card" data-title="House-to-House Energy Sharing">
        <h2>9. House-to-House Energy Sharing (Peer-to-Peer Grid)</h2>
        <div class="meta">If one house produces more solar energy than needed, it transfers to neighbors.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Compare production vs consumption of each house.</li>
            <li>Houses with surplus transfer to deficit houses.</li>
            <li>Track credits digitally.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Simple hash map for credits
class CreditLedger:
    def __init__(self):
        self.ledger = {}
    def credit(self, user, amount):
        self.ledger[user] = self.ledger.get(user,0) + amount
    def debit(self, user, amount):
        if self.ledger.get(user,0) >= amount:
            self.ledger[user] -= amount
            return True
        return False

# end
</code></pre>
        </div>
      </section>

      <!-- Card 10: Smart Load Control + Stack and Queue examples -->
      <section class="card" data-title="Smart Load Control Inside Homes & Factories">
        <h2>10. Smart Load Control Inside Homes & Factories</h2>
        <div class="meta">Turns off low-priority devices automatically when city demand is high.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Monitor city peak load time.</li>
            <li>Classify appliances: high priority / low priority.</li>
            <li>Turn off low-priority loads during peak.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Stack & Queue examples
class Stack:
    def __init__(self): self.s = []
    def push(self, x): self.s.append(x)
    def pop(self): return self.s.pop() if self.s else None

from collections import deque
class Queue:
    def __init__(self): self.q = deque()
    def enqueue(self, x): self.q.append(x)
    def dequeue(self): return self.q.popleft() if self.q else None

# end
</code></pre>
        </div>
      </section>

      <!-- Card 11: Microgrid Islanding + Union-Find (disjoint set) -->
      <section class="card" data-title="AI-Based Microgrid Islanding System">
        <h2>11. AI-Based Microgrid Islanding System</h2>
        <div class="meta">Automatically separates a microgrid during faults, keeping power ON locally.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Monitor main grid stability (frequency + voltage).</li>
            <li>Detect fault conditions or instability.</li>
            <li>Automatically isolate microgrid using switches.</li>
            <li>Use local solar + wind + battery to keep supply stable.</li>
            <li>Reconnect when grid becomes stable.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Disjoint set union (for grouping islanded nodes)
class DSU:
    def __init__(self,n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self,x):
        if self.p[x]!=x:
            self.p[x]=self.find(self.p[x])
        return self.p[x]
    def union(self,a,b):
        ra,rb = self.find(a), self.find(b)
        if ra==rb: return
        if self.r[ra]<self.r[rb]: ra,rb = rb,ra
        self.p[rb]=ra
        if self.r[ra]==self.r[rb]: self.r[ra]+=1

# end
</code></pre>
        </div>
      </section>

      <!-- Card 12: Predictive Maintenance + Logistic regression snippet -->
      <section class="card" data-title="Predictive Maintenance for Transformers">
        <h2>12. Predictive Maintenance for Transformers & Powerhouse Machines</h2>
        <div class="meta">AI predicts failure of transformers, generators, and inverters.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Collect temperature, vibration, current readings.</li>
            <li>Run anomaly detection model.</li>
            <li>Predict failure probability.</li>
            <li>Generate maintenance task if risk &gt; threshold.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Simple logistic regression score (manual)
def sigmoid(x):
    return 1/(1+math.exp(-x))

def predict_risk(features, weights, bias):
    s = sum(f*w for f,w in zip(features,weights)) + bias
    return sigmoid(s)

# end
</code></pre>
        </div>
      </section>

      <!-- Card 13: Dynamic Load Balancer + Graph edges transfer example -->
      <section class="card" data-title="AI Dynamic Load Balancer">
        <h2>13. AI Dynamic Load Balancer for City Zones</h2>
        <div class="meta">Balances power loads between city sectors to prevent blackouts.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Detect overloaded zones.</li>
            <li>Check spare capacity in other zones.</li>
            <li>Redirect energy using smart-switch routing.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># transfer function (graph-based)
def transfer_power(graph, from_zone, to_zone, amount):
    # graph holds capacity info per edge
    if graph[from_zone][to_zone]['capacity'] >= amount:
        graph[from_zone][to_zone]['capacity'] -= amount
        graph[to_zone][from_zone]['capacity'] += amount
        return True
    return False

# end
</code></pre>
        </div>
      </section>

      <!-- Card 14: Renewable Forecasting + FFT placeholder -->
      <section class="card" data-title="Renewable Energy Forecasting System">
        <h2>14. Renewable Energy Forecasting System</h2>
        <div class="meta">Predict next day’s solar + wind generation.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Collect weather forecast (sunlight, wind speed).</li>
            <li>Use ML model to predict energy production.</li>
            <li>Adjust powerhouse production accordingly.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Placeholder: use FFT or ML for seasonality detection
# from numpy.fft import rfft
# spectrum = rfft(past_generation_series)

# end
</code></pre>
        </div>
      </section>

      <!-- Card 15: EV Charging + Scheduling (greedy) -->
      <section class="card" data-title="AI-Controlled EV Charging Stations">
        <h2>15. AI-Controlled EV Charging Stations</h2>
        <div class="meta">Controls EV charging speed to avoid overloading the grid.</div>
        <div class="alg"><strong>Algorithm:</strong>
          <ol>
            <li>Get current grid load.</li>
            <li>If peak load → slow charging.</li>
            <li>Schedule charging during low-demand windows.</li>
          </ol>
        </div>
        <div class="btn-row card-controls">
          <button class="btn" onclick="toggleCode(this)">View Code</button>
          <button class="btn small" onclick="copySnippet(this)">Copy Snippet</button>
        </div>
        <div class="code-panel">
          <pre><code># Greedy scheduler for EV chargers
def schedule_charging(ev_list, capacity):
    # ev_list: [(ev_id, required_kwh, deadline_hour)]
    ev_list.sort(key=lambda x: x[2]) # earliest deadline first
    schedule = {}
    for ev in ev_list:
        ev_id, need, dl = ev
        assign = min(need, capacity)
        schedule[ev_id] = assign
        capacity -= assign
        if capacity <= 0:
            break
    return schedule

# end
</code></pre>
        </div>
      </section>

      <section class="card full">
        <h2>How to use</h2>
        <p class="meta">Click "View Code" on an idea to reveal the business code and algorithm examples. Use the search box to filter cards. Use "Copy Snippet" to copy the revealed snippet (if panel is shown).</p>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
          <button class="btn" onclick="downloadHTML()">Download HTML</button>
          <button class="btn" onclick="expandAll()">Expand All</button>
          <button class="btn" onclick="collapseAll()">Collapse All</button>
        </div>
      </section>

    </div>

    <footer>
      Generated: AI Powerhouse & Renewable Energy — ideas (HTML) with hidden algorithm snippets. Edit or ask for additional export formats (PDF, Markdown, React component).
    </footer>
  </div>

  <script>
    function toggleCode(btn){
      const card = btn.closest('.card');
      const panel = card.querySelector('.code-panel');
      if(!panel) return;
      panel.classList.toggle('show');
      btn.innerText = panel.classList.contains('show') ? 'Hide Code' : 'View Code';
    }
    function copySnippet(btn){
      const card = btn.closest('.card');
      const panel = card.querySelector('.code-panel');
      if(!panel) return alert('Open the code first to copy.');
      const text = panel.innerText;
      navigator.clipboard.writeText(text).then(()=>{
        const old = btn.innerText;
        btn.innerText = 'Copied ✓';
        setTimeout(()=> btn.innerText = old, 1500);
      });
    }
    function downloadHTML(){
      const html = document.documentElement.outerHTML;
      const blob = new Blob([html], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'ai-powerhouse-ideas-algos.html';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    function expandAll(){
      document.querySelectorAll('.code-panel').forEach(p=>{p.classList.add('show');});
      document.querySelectorAll('.card .btn').forEach(b=>{ if(b.innerText==='View Code') b.innerText='Hide Code'; });
    }
    function collapseAll(){
      document.querySelectorAll('.code-panel').forEach(p=>{p.classList.remove('show');});
      document.querySelectorAll('.card .btn').forEach(b=>{ if(b.innerText==='Hide Code') b.innerText='View Code'; });
    }
    // Search/filter
    document.getElementById('search').addEventListener('input', function(e){
      const q = e.target.value.toLowerCase();
      document.querySelectorAll('#grid .card').forEach(card=>{
        const title = (card.getAttribute('data-title')||'').toLowerCase();
        const text = card.innerText.toLowerCase();
        if(title.includes(q) || text.includes(q)) card.style.display = '';
        else card.style.display = 'none';
      });
    });
    // Prevent accidental code visibility on load
    collapseAll();
  </script>
</body>
</html>
